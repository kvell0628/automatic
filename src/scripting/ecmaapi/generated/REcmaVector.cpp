// ***** AUTOGENERATED CODE, DO NOT EDIT *****
            // ***** This class is copyable.
        
        #include "REcmaVector.h"
        #include "RMetaTypes.h"
        #include "../REcmaHelper.h"

        // forwards declarations mapped to includes
        
                #include "RMatrix.h"
            
                #include "RBox.h"
            
                #include "RLine.h"
            
                #include "RPolyline.h"
            
            
        // includes for base ecma wrapper classes
         void REcmaVector::initEcma(QScriptEngine& engine, QScriptValue* proto 
    
    ) 
    
    {

    bool protoCreated = false;
    if(proto == NULL){
        proto = new QScriptValue(engine.newVariant(qVariantFromValue(
                (RVector*) 0)));
        protoCreated = true;
    }

    

    QScriptValue fun;

    // toString:
    REcmaHelper::registerFunction(&engine, proto, toString, "toString");
    
    // copy:
    REcmaHelper::registerFunction(&engine, proto, copy, "copy");
    

    // destroy:
    REcmaHelper::registerFunction(&engine, proto, destroy, "destroy");
    

    // get class name
    REcmaHelper::registerFunction(&engine, proto, getClassName, "getClassName");
    

    // conversion to all base classes (multiple inheritance):
    REcmaHelper::registerFunction(&engine, proto, getBaseClasses, "getBaseClasses");
    

    // properties:
    
            proto->setProperty("x", engine.newFunction(
                getSetX),
                QScriptValue::PropertyGetter
                
                    | QScriptValue::PropertySetter
                
            );          
            
            proto->setProperty("y", engine.newFunction(
                getSetY),
                QScriptValue::PropertyGetter
                
                    | QScriptValue::PropertySetter
                
            );          
            
            proto->setProperty("z", engine.newFunction(
                getSetZ),
                QScriptValue::PropertyGetter
                
                    | QScriptValue::PropertySetter
                
            );          
            
            proto->setProperty("valid", engine.newFunction(
                getSetValid),
                QScriptValue::PropertyGetter
                
            );          
            

    // methods:
    
            REcmaHelper::registerFunction(&engine, proto, set, "set");
            
            REcmaHelper::registerFunction(&engine, proto, setPolar, "setPolar");
            
            REcmaHelper::registerFunction(&engine, proto, get2D, "get2D");
            
            REcmaHelper::registerFunction(&engine, proto, isValid, "isValid");
            
            REcmaHelper::registerFunction(&engine, proto, isZero, "isZero");
            
            REcmaHelper::registerFunction(&engine, proto, isSane, "isSane");
            
            REcmaHelper::registerFunction(&engine, proto, isNaN, "isNaN");
            
            REcmaHelper::registerFunction(&engine, proto, isInside, "isInside");
            
            REcmaHelper::registerFunction(&engine, proto, equalsFuzzy, "equalsFuzzy");
            
            REcmaHelper::registerFunction(&engine, proto, equalsFuzzy2D, "equalsFuzzy2D");
            
            REcmaHelper::registerFunction(&engine, proto, getDistanceTo, "getDistanceTo");
            
            REcmaHelper::registerFunction(&engine, proto, getDistanceTo2D, "getDistanceTo2D");
            
            REcmaHelper::registerFunction(&engine, proto, setAngle, "setAngle");
            
            REcmaHelper::registerFunction(&engine, proto, getAngle, "getAngle");
            
            REcmaHelper::registerFunction(&engine, proto, getAngleToPlaneXY, "getAngleToPlaneXY");
            
            REcmaHelper::registerFunction(&engine, proto, getAngleTo, "getAngleTo");
            
            REcmaHelper::registerFunction(&engine, proto, setMagnitude2D, "setMagnitude2D");
            
            REcmaHelper::registerFunction(&engine, proto, getMagnitude, "getMagnitude");
            
            REcmaHelper::registerFunction(&engine, proto, getSquaredMagnitude, "getSquaredMagnitude");
            
            REcmaHelper::registerFunction(&engine, proto, getMagnitude2D, "getMagnitude2D");
            
            REcmaHelper::registerFunction(&engine, proto, getLerp, "getLerp");
            
            REcmaHelper::registerFunction(&engine, proto, getUnitVector, "getUnitVector");
            
            REcmaHelper::registerFunction(&engine, proto, setX, "setX");
            
            REcmaHelper::registerFunction(&engine, proto, getX, "getX");
            
            REcmaHelper::registerFunction(&engine, proto, setY, "setY");
            
            REcmaHelper::registerFunction(&engine, proto, getY, "getY");
            
            REcmaHelper::registerFunction(&engine, proto, setZ, "setZ");
            
            REcmaHelper::registerFunction(&engine, proto, getZ, "getZ");
            
            REcmaHelper::registerFunction(&engine, proto, isInWindow, "isInWindow");
            
            REcmaHelper::registerFunction(&engine, proto, move, "move");
            
            REcmaHelper::registerFunction(&engine, proto, rotate, "rotate");
            
            REcmaHelper::registerFunction(&engine, proto, getRotated, "getRotated");
            
            REcmaHelper::registerFunction(&engine, proto, rotate3D, "rotate3D");
            
            REcmaHelper::registerFunction(&engine, proto, scale, "scale");
            
            REcmaHelper::registerFunction(&engine, proto, getScaled, "getScaled");
            
            REcmaHelper::registerFunction(&engine, proto, mirror, "mirror");
            
            REcmaHelper::registerFunction(&engine, proto, getMirrored, "getMirrored");
            
            REcmaHelper::registerFunction(&engine, proto, flipHorizontal, "flipHorizontal");
            
            REcmaHelper::registerFunction(&engine, proto, flipVertical, "flipVertical");
            
            REcmaHelper::registerFunction(&engine, proto, stretch, "stretch");
            
            REcmaHelper::registerFunction(&engine, proto, isoProject, "isoProject");
            
            REcmaHelper::registerFunction(&engine, proto, axonometricProjection, "axonometricProjection");
            
            REcmaHelper::registerFunction(&engine, proto, obliqueProjection, "obliqueProjection");
            
            REcmaHelper::registerFunction(&engine, proto, transform, "transform");
            
            REcmaHelper::registerFunction(&engine, proto, transform2DM, "transform2DM");
            
            REcmaHelper::registerFunction(&engine, proto, transform2D, "transform2D");
            
            REcmaHelper::registerFunction(&engine, proto, getTransformed, "getTransformed");
            
            REcmaHelper::registerFunction(&engine, proto, getTransformed2DM, "getTransformed2DM");
            
            REcmaHelper::registerFunction(&engine, proto, getTransformed2D, "getTransformed2D");
            
            REcmaHelper::registerFunction(&engine, proto, getDividedComponents, "getDividedComponents");
            
            REcmaHelper::registerFunction(&engine, proto, getMultipliedComponents, "getMultipliedComponents");
            
            REcmaHelper::registerFunction(&engine, proto, getClosest, "getClosest");
            
            REcmaHelper::registerFunction(&engine, proto, getClosest2D, "getClosest2D");
            
            REcmaHelper::registerFunction(&engine, proto, getClosestDistance, "getClosestDistance");
            
            REcmaHelper::registerFunction(&engine, proto, getClosestIndex, "getClosestIndex");
            
            REcmaHelper::registerFunction(&engine, proto, getClosestIndex2D, "getClosestIndex2D");
            
            REcmaHelper::registerFunction(&engine, proto, operator_add, "operator_add");
            
            REcmaHelper::registerFunction(&engine, proto, operator_subtract, "operator_subtract");
            
            REcmaHelper::registerFunction(&engine, proto, operator_multiply, "operator_multiply");
            
            REcmaHelper::registerFunction(&engine, proto, operator_divide, "operator_divide");
            
            REcmaHelper::registerFunction(&engine, proto, getNegated, "getNegated");
            
            REcmaHelper::registerFunction(&engine, proto, getAbsolute, "getAbsolute");
            
            REcmaHelper::registerFunction(&engine, proto, dot, "dot");
            
            REcmaHelper::registerFunction(&engine, proto, normalize, "normalize");
            
            REcmaHelper::registerFunction(&engine, proto, getNormalized, "getNormalized");
            
            REcmaHelper::registerFunction(&engine, proto, operator_add_assign, "operator_add_assign");
            
            REcmaHelper::registerFunction(&engine, proto, operator_subtract_assign, "operator_subtract_assign");
            
            REcmaHelper::registerFunction(&engine, proto, operator_multiply_assign, "operator_multiply_assign");
            
            REcmaHelper::registerFunction(&engine, proto, operator_divide_assign, "operator_divide_assign");
            
            REcmaHelper::registerFunction(&engine, proto, equals, "equals");
            
            REcmaHelper::registerFunction(&engine, proto, operator_not_assign, "operator_not_assign");
            
            REcmaHelper::registerFunction(&engine, proto, getFloor, "getFloor");
            
            REcmaHelper::registerFunction(&engine, proto, getCeil, "getCeil");
            
            REcmaHelper::registerFunction(&engine, proto, lteXY, "lteXY");
            
            REcmaHelper::registerFunction(&engine, proto, gteXY, "gteXY");
            
        engine.setDefaultPrototype(
            qMetaTypeId<RVector*>(), *proto);

        
                engine.setDefaultPrototype(qMetaTypeId<
                RVector
                > (), *proto);
            
    

    QScriptValue ctor = engine.newFunction(createEcma, *proto, 2);
    
    // static methods:
    
            REcmaHelper::registerFunction(&engine, &ctor, containsFuzzy, "containsFuzzy");
            
            REcmaHelper::registerFunction(&engine, &ctor, findFirstFuzzy, "findFirstFuzzy");
            
            REcmaHelper::registerFunction(&engine, &ctor, getMinimum, "getMinimum");
            
            REcmaHelper::registerFunction(&engine, &ctor, getMaximum, "getMaximum");
            
            REcmaHelper::registerFunction(&engine, &ctor, getMinimumX, "getMinimumX");
            
            REcmaHelper::registerFunction(&engine, &ctor, getMaximumX, "getMaximumX");
            
            REcmaHelper::registerFunction(&engine, &ctor, getMinimumY, "getMinimumY");
            
            REcmaHelper::registerFunction(&engine, &ctor, getMaximumY, "getMaximumY");
            
            REcmaHelper::registerFunction(&engine, &ctor, getAverage, "getAverage");
            
            REcmaHelper::registerFunction(&engine, &ctor, getUnion, "getUnion");
            
            REcmaHelper::registerFunction(&engine, &ctor, getUnique, "getUnique");
            
            REcmaHelper::registerFunction(&engine, &ctor, getXList, "getXList");
            
            REcmaHelper::registerFunction(&engine, &ctor, getYList, "getYList");
            
            REcmaHelper::registerFunction(&engine, &ctor, getZList, "getZList");
            
            REcmaHelper::registerFunction(&engine, &ctor, getCrossProduct, "getCrossProduct");
            
            REcmaHelper::registerFunction(&engine, &ctor, getDotProduct, "getDotProduct");
            
            REcmaHelper::registerFunction(&engine, &ctor, createPolar, "createPolar");
            
            REcmaHelper::registerFunction(&engine, &ctor, lessThanX, "lessThanX");
            
            REcmaHelper::registerFunction(&engine, &ctor, greaterThanX, "greaterThanX");
            
            REcmaHelper::registerFunction(&engine, &ctor, lessThanY, "lessThanY");
            
            REcmaHelper::registerFunction(&engine, &ctor, greaterThanY, "greaterThanY");
            
            REcmaHelper::registerFunction(&engine, &ctor, lessThanEqualXY, "lessThanEqualXY");
            
            REcmaHelper::registerFunction(&engine, &ctor, greaterThanEqualXY, "greaterThanEqualXY");
            
            REcmaHelper::registerFunction(&engine, &ctor, getSortedByDistance, "getSortedByDistance");
            
            REcmaHelper::registerFunction(&engine, &ctor, getSortedLeftRightTopBottom, "getSortedLeftRightTopBottom");
            
            REcmaHelper::registerFunction(&engine, &ctor, getSortedByAngle, "getSortedByAngle");
            

    // static properties:
    
            ctor.setProperty("invalid",
                qScriptValueFromValue(&engine, RVector::invalid),
                QScriptValue::SkipInEnumeration | QScriptValue::ReadOnly);
            
            ctor.setProperty("nullVector",
                qScriptValueFromValue(&engine, RVector::nullVector),
                QScriptValue::SkipInEnumeration | QScriptValue::ReadOnly);
            
            ctor.setProperty("nanVector",
                qScriptValueFromValue(&engine, RVector::nanVector),
                QScriptValue::SkipInEnumeration | QScriptValue::ReadOnly);
            

    // enum values:
    

    // enum conversions:
    
        
    // init class:
    engine.globalObject().setProperty("RVector",
    ctor, QScriptValue::SkipInEnumeration);
    
    if( protoCreated ){
       delete proto;
    }
    
    }
     QScriptValue REcmaVector::createEcma(QScriptContext* context, QScriptEngine* engine) 
    
    {
    if (context->thisObject().strictlyEquals(
       engine->globalObject())) {
       return REcmaHelper::throwError(
       QString::fromLatin1("RVector(): Did you forget to construct with 'new'?"),
           context);
    }

    QScriptValue result;
        
            // generate constructor variants:
            
    if( context->argumentCount() ==
        0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ constructor:
    
            // copyable class:
            RVector
                    cppResult;
                
            result = engine->newVariant(
            context->thisObject(), qVariantFromValue(cppResult));
        
    } else 

    if( context->argumentCount() ==
        2
                && (
                
                        context->argument(
                        0
                        ).isNumber()
                ) /* type: double */
            
                && (
                
                        context->argument(
                        1
                        ).isNumber()
                ) /* type: double */
            
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
                    // argument isStandardType
                    double
                    a1 =
                    (double)
                    
                    context->argument( 1 ).
                    toNumber();
                
    // end of arguments

    // call C++ constructor:
    
            // copyable class:
            RVector
                    cppResult(
                    a0
        ,
    a1
                    );
                
            result = engine->newVariant(
            context->thisObject(), qVariantFromValue(cppResult));
        
    } else 

    if( context->argumentCount() ==
        3
                && (
                
                        context->argument(
                        0
                        ).isNumber()
                ) /* type: double */
            
                && (
                
                        context->argument(
                        1
                        ).isNumber()
                ) /* type: double */
            
                && (
                
                        context->argument(
                        2
                        ).isNumber()
                ) /* type: double */
            
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
                    // argument isStandardType
                    double
                    a1 =
                    (double)
                    
                    context->argument( 1 ).
                    toNumber();
                
                    // argument isStandardType
                    double
                    a2 =
                    (double)
                    
                    context->argument( 2 ).
                    toNumber();
                
    // end of arguments

    // call C++ constructor:
    
            // copyable class:
            RVector
                    cppResult(
                    a0
        ,
    a1
        ,
    a2
                    );
                
            result = engine->newVariant(
            context->thisObject(), qVariantFromValue(cppResult));
        
    } else 

    if( context->argumentCount() ==
        4
                && (
                
                        context->argument(
                        0
                        ).isNumber()
                ) /* type: double */
            
                && (
                
                        context->argument(
                        1
                        ).isNumber()
                ) /* type: double */
            
                && (
                
                        context->argument(
                        2
                        ).isNumber()
                ) /* type: double */
            
                && (
                
                        context->argument(
                        3
                        ).isBool()
                ) /* type: bool */
            
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
                    // argument isStandardType
                    double
                    a1 =
                    (double)
                    
                    context->argument( 1 ).
                    toNumber();
                
                    // argument isStandardType
                    double
                    a2 =
                    (double)
                    
                    context->argument( 2 ).
                    toNumber();
                
                    // argument isStandardType
                    bool
                    a3 =
                    (bool)
                    
                    context->argument( 3 ).
                    toBool();
                
    // end of arguments

    // call C++ constructor:
    
            // copyable class:
            RVector
                    cppResult(
                    a0
        ,
    a1
        ,
    a2
        ,
    a3
                    );
                
            result = engine->newVariant(
            context->thisObject(), qVariantFromValue(cppResult));
        
    } else 

    if( context->argumentCount() ==
        1
                && (
                
                        context->argument(
                        0
                        ).isArray()
                ) /* type: QList < double > */
            
    ){
    // prepare arguments:
    
                    // argument isArray
                    QList < double >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
    // end of arguments

    // call C++ constructor:
    
            // copyable class:
            RVector
                    cppResult(
                    a0
                    );
                
            result = engine->newVariant(
            context->thisObject(), qVariantFromValue(cppResult));
        
    } else 

    {
       return REcmaHelper::throwError(
       QString::fromLatin1("RVector(): no matching constructor found."),
           context);
    }
    
    return result;
    }
    

    // conversion functions for base classes:
    

    // returns class name:
     QScriptValue REcmaVector::getClassName(QScriptContext *context, QScriptEngine *engine) 
        
    {
        return qScriptValueFromValue(engine, QString("RVector"));
    }
    

    // returns all base classes (in case of multiple inheritance):
     QScriptValue REcmaVector::getBaseClasses(QScriptContext *context, QScriptEngine *engine) 
        
    {
        QStringList list;
        

        return qScriptValueFromSequence(engine, list);
    }
    

    // properties:
     QScriptValue REcmaVector::getSetX
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
        RVector* self = getSelf("x", context);
        //Q_ASSERT(self!=NULL);
        if (self==NULL) {
            return REcmaHelper::throwError("self is NULL", context);
        }
        
            if(context->argumentCount() == 1){
                
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
                self->setX(a0);
            }
        double
        cppResult = self->
        getX();
        QScriptValue result;
        
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
        return result;
        }
         QScriptValue REcmaVector::getSetY
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
        RVector* self = getSelf("y", context);
        //Q_ASSERT(self!=NULL);
        if (self==NULL) {
            return REcmaHelper::throwError("self is NULL", context);
        }
        
            if(context->argumentCount() == 1){
                
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
                self->setY(a0);
            }
        double
        cppResult = self->
        getY();
        QScriptValue result;
        
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
        return result;
        }
         QScriptValue REcmaVector::getSetZ
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
        RVector* self = getSelf("z", context);
        //Q_ASSERT(self!=NULL);
        if (self==NULL) {
            return REcmaHelper::throwError("self is NULL", context);
        }
        
            if(context->argumentCount() == 1){
                
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
                self->setZ(a0);
            }
        double
        cppResult = self->
        getZ();
        QScriptValue result;
        
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
        return result;
        }
         QScriptValue REcmaVector::getSetValid
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
        RVector* self = getSelf("valid", context);
        //Q_ASSERT(self!=NULL);
        if (self==NULL) {
            return REcmaHelper::throwError("self is NULL", context);
        }
        bool
        cppResult = self->
        isValid();
        QScriptValue result;
        
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
        return result;
        }
        

    // public methods:
     QScriptValue
        REcmaVector::set
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::set", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::set";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("set", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isNumber()
        ) /* type: double */
     && (
            context->argument(1).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
                    // argument isStandardType
                    double
                    a1 =
                    (double)
                    
                    context->argument( 1 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->set(a0
        ,
    a1);
    } else


        
    
    if( context->argumentCount() ==
    3 && (
            context->argument(0).isNumber()
        ) /* type: double */
     && (
            context->argument(1).isNumber()
        ) /* type: double */
     && (
            context->argument(2).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
                    // argument isStandardType
                    double
                    a1 =
                    (double)
                    
                    context->argument( 1 ).
                    toNumber();
                
                    // argument isStandardType
                    double
                    a2 =
                    (double)
                    
                    context->argument( 2 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->set(a0
        ,
    a1
        ,
    a2);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.set().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::set", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::setPolar
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::setPolar", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::setPolar";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("setPolar", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isNumber()
        ) /* type: double */
     && (
            context->argument(1).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
                    // argument isStandardType
                    double
                    a1 =
                    (double)
                    
                    context->argument( 1 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setPolar(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.setPolar().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::setPolar", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::get2D
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::get2D", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::get2D";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("get2D", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->get2D();
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.get2D().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::get2D", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::isValid
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::isValid", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::isValid";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("isValid", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->isValid();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.isValid().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::isValid", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::isZero
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::isZero", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::isZero";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("isZero", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->isZero();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.isZero().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::isZero", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::isSane
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::isSane", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::isSane";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("isSane", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->isSane();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.isSane().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::isSane", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::isNaN
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::isNaN", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::isNaN";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("isNaN", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->isNaN();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.isNaN().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::isNaN", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::isInside
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::isInside", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::isInside";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("isInside", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RBox */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RBox*
                    ap0 =
                    qscriptvalue_cast<
                    RBox*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RBox.",
                               context);                    
                    }
                    RBox 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->isInside(a0);
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.isInside().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::isInside", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::equalsFuzzy
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::equalsFuzzy", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::equalsFuzzy";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("equalsFuzzy", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->equalsFuzzy(a0);
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isStandardType
                    double
                    a1 =
                    (double)
                    
                    context->argument( 1 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->equalsFuzzy(a0
        ,
    a1);
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.equalsFuzzy().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::equalsFuzzy", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::equalsFuzzy2D
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::equalsFuzzy2D", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::equalsFuzzy2D";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("equalsFuzzy2D", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->equalsFuzzy2D(a0);
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isStandardType
                    double
                    a1 =
                    (double)
                    
                    context->argument( 1 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->equalsFuzzy2D(a0
        ,
    a1);
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.equalsFuzzy2D().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::equalsFuzzy2D", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getDistanceTo
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getDistanceTo", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getDistanceTo";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("getDistanceTo", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'double'
    double cppResult =
        
               self->getDistanceTo(a0);
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getDistanceTo().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getDistanceTo", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getDistanceTo2D
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getDistanceTo2D", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getDistanceTo2D";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("getDistanceTo2D", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'double'
    double cppResult =
        
               self->getDistanceTo2D(a0);
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getDistanceTo2D().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getDistanceTo2D", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::setAngle
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::setAngle", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::setAngle";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("setAngle", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setAngle(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.setAngle().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::setAngle", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getAngle
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getAngle", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getAngle";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("getAngle", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'double'
    double cppResult =
        
               self->getAngle();
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getAngle().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getAngle", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getAngleToPlaneXY
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getAngleToPlaneXY", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getAngleToPlaneXY";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("getAngleToPlaneXY", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'double'
    double cppResult =
        
               self->getAngleToPlaneXY();
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getAngleToPlaneXY().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getAngleToPlaneXY", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getAngleTo
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getAngleTo", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getAngleTo";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("getAngleTo", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'double'
    double cppResult =
        
               self->getAngleTo(a0);
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getAngleTo().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getAngleTo", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::setMagnitude2D
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::setMagnitude2D", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::setMagnitude2D";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("setMagnitude2D", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setMagnitude2D(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.setMagnitude2D().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::setMagnitude2D", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getMagnitude
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getMagnitude", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getMagnitude";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("getMagnitude", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'double'
    double cppResult =
        
               self->getMagnitude();
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getMagnitude().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getMagnitude", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getSquaredMagnitude
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getSquaredMagnitude", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getSquaredMagnitude";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("getSquaredMagnitude", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'double'
    double cppResult =
        
               self->getSquaredMagnitude();
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getSquaredMagnitude().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getSquaredMagnitude", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getMagnitude2D
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getMagnitude2D", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getMagnitude2D";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("getMagnitude2D", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'double'
    double cppResult =
        
               self->getMagnitude2D();
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getMagnitude2D().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getMagnitude2D", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getLerp
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getLerp", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getLerp";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("getLerp", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isStandardType
                    double
                    a1 =
                    (double)
                    
                    context->argument( 1 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->getLerp(a0
        ,
    a1);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getLerp().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getLerp", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getUnitVector
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getUnitVector", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getUnitVector";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("getUnitVector", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->getUnitVector();
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getUnitVector().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getUnitVector", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::setX
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::setX", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::setX";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("setX", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setX(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.setX().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::setX", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getX
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getX", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getX";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("getX", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'double'
    double cppResult =
        
               self->getX();
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getX().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getX", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::setY
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::setY", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::setY";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("setY", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setY(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.setY().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::setY", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getY
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getY", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getY";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("getY", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'double'
    double cppResult =
        
               self->getY();
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getY().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getY", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::setZ
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::setZ", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::setZ";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("setZ", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setZ(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.setZ().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::setZ", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getZ
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getZ", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getZ";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("getZ", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'double'
    double cppResult =
        
               self->getZ();
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getZ().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getZ", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::isInWindow
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::isInWindow", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::isInWindow";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("isInWindow", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap1 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 1 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a1 = 
                    *ap1;
                
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->isInWindow(a0
        ,
    a1);
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.isInWindow().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::isInWindow", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::move
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::move", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::move";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("move", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->move(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.move().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::move", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::rotate
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::rotate", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::rotate";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("rotate", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->rotate(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isNumber()
        ) /* type: double */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap1 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 1 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a1 = 
                    *ap1;
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->rotate(a0
        ,
    a1);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.rotate().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::rotate", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getRotated
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getRotated", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getRotated";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("getRotated", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isNumber()
        ) /* type: double */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap1 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 1 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a1 = 
                    *ap1;
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->getRotated(a0
        ,
    a1);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getRotated().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getRotated", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::rotate3D
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::rotate3D", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::rotate3D";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("rotate3D", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RLine */
     && (
            context->argument(1).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RLine*
                    ap0 =
                    qscriptvalue_cast<
                    RLine*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RLine.",
                               context);                    
                    }
                    RLine 
                    a0 = 
                    *ap0;
                
                    // argument isStandardType
                    double
                    a1 =
                    (double)
                    
                    context->argument( 1 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->rotate3D(a0
        ,
    a1);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: QQuaternion */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    QQuaternion*
                    ap0 =
                    qscriptvalue_cast<
                    QQuaternion*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type QQuaternion*.",
                               context);                    
                    }
                    QQuaternion& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->rotate3D(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.rotate3D().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::rotate3D", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::scale
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::scale", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::scale";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("scale", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->scale(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isNumber()
        ) /* type: double */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap1 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 1 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a1 = 
                    *ap1;
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->scale(a0
        ,
    a1);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->scale(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap1 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 1 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a1 = 
                    *ap1;
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->scale(a0
        ,
    a1);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.scale().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::scale", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getScaled
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getScaled", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getScaled";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("getScaled", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap1 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 1 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a1 = 
                    *ap1;
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->getScaled(a0
        ,
    a1);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getScaled().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getScaled", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::mirror
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::mirror", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::mirror";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("mirror", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RLine */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RLine*
                    ap0 =
                    qscriptvalue_cast<
                    RLine*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RLine.",
                               context);                    
                    }
                    RLine 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->mirror(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap1 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 1 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a1 = 
                    *ap1;
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->mirror(a0
        ,
    a1);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.mirror().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::mirror", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getMirrored
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getMirrored", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getMirrored";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("getMirrored", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RLine */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RLine*
                    ap0 =
                    qscriptvalue_cast<
                    RLine*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RLine.",
                               context);                    
                    }
                    RLine 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->getMirrored(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getMirrored().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getMirrored", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::flipHorizontal
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::flipHorizontal", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::flipHorizontal";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("flipHorizontal", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->flipHorizontal();
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.flipHorizontal().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::flipHorizontal", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::flipVertical
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::flipVertical", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::flipVertical";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("flipVertical", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->flipVertical();
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.flipVertical().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::flipVertical", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::stretch
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::stretch", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::stretch";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("stretch", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RPolyline */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RPolyline*
                    ap0 =
                    qscriptvalue_cast<
                    RPolyline*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RPolyline.",
                               context);                    
                    }
                    RPolyline 
                    a0 = 
                    *ap0;
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap1 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 1 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a1 = 
                    *ap1;
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->stretch(a0
        ,
    a1);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.stretch().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::stretch", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::isoProject
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::isoProject", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::isoProject";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("isoProject", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: RS::IsoProjectionType */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    RS::IsoProjectionType
                    a0 =
                    (RS::IsoProjectionType)
                    (int)
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->isoProject(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.isoProject().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::isoProject", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::axonometricProjection
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::axonometricProjection", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::axonometricProjection";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("axonometricProjection", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: RS::IsoProjectionType */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    RS::IsoProjectionType
                    a0 =
                    (RS::IsoProjectionType)
                    (int)
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->axonometricProjection(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.axonometricProjection().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::axonometricProjection", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::obliqueProjection
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::obliqueProjection", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::obliqueProjection";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("obliqueProjection", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: RS::IsoProjectionType */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    RS::IsoProjectionType
                    a0 =
                    (RS::IsoProjectionType)
                    (int)
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->obliqueProjection(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.obliqueProjection().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::obliqueProjection", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::transform
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::transform", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::transform";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("transform", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RMatrix */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RMatrix*
                    ap0 =
                    qscriptvalue_cast<
                    RMatrix*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RMatrix.",
                               context);                    
                    }
                    RMatrix 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->transform(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.transform().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::transform", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::transform2DM
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::transform2DM", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::transform2DM";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("transform2DM", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RMatrix */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RMatrix*
                    ap0 =
                    qscriptvalue_cast<
                    RMatrix*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RMatrix.",
                               context);                    
                    }
                    RMatrix 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->transform2DM(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.transform2DM().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::transform2DM", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::transform2D
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::transform2D", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::transform2D";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("transform2D", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: QTransform */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    QTransform*
                    ap0 =
                    qscriptvalue_cast<
                    QTransform*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type QTransform*.",
                               context);                    
                    }
                    QTransform& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->transform2D(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.transform2D().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::transform2D", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getTransformed
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getTransformed", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getTransformed";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("getTransformed", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RMatrix */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RMatrix*
                    ap0 =
                    qscriptvalue_cast<
                    RMatrix*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RMatrix.",
                               context);                    
                    }
                    RMatrix 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->getTransformed(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getTransformed().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getTransformed", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getTransformed2DM
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getTransformed2DM", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getTransformed2DM";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("getTransformed2DM", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RMatrix */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RMatrix*
                    ap0 =
                    qscriptvalue_cast<
                    RMatrix*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RMatrix.",
                               context);                    
                    }
                    RMatrix 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->getTransformed2DM(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getTransformed2DM().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getTransformed2DM", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getTransformed2D
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getTransformed2D", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getTransformed2D";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("getTransformed2D", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: QTransform */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    QTransform*
                    ap0 =
                    qscriptvalue_cast<
                    QTransform*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type QTransform*.",
                               context);                    
                    }
                    QTransform& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->getTransformed2D(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getTransformed2D().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getTransformed2D", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getDividedComponents
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getDividedComponents", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getDividedComponents";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("getDividedComponents", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->getDividedComponents(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getDividedComponents().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getDividedComponents", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getMultipliedComponents
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getMultipliedComponents", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getMultipliedComponents";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("getMultipliedComponents", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->getMultipliedComponents(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getMultipliedComponents().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getMultipliedComponents", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getClosest
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getClosest", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getClosest";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("getClosest", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isArray()
        ) /* type: QList < RVector > */
    
    ){
    // prepare arguments:
    
                    // argument isArray
                    QList < RVector >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->getClosest(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getClosest().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getClosest", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getClosest2D
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getClosest2D", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getClosest2D";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("getClosest2D", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isArray()
        ) /* type: QList < RVector > */
    
    ){
    // prepare arguments:
    
                    // argument isArray
                    QList < RVector >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->getClosest2D(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getClosest2D().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getClosest2D", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getClosestDistance
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getClosestDistance", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getClosestDistance";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("getClosestDistance", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isArray()
        ) /* type: QList < RVector > */
     && (
            context->argument(1).isNumber()
        ) /* type: int */
    
    ){
    // prepare arguments:
    
                    // argument isArray
                    QList < RVector >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
                    // argument isStandardType
                    int
                    a1 =
                    (int)
                    
                    context->argument( 1 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'double'
    double cppResult =
        
               self->getClosestDistance(a0
        ,
    a1);
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getClosestDistance().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getClosestDistance", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getClosestIndex
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getClosestIndex", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getClosestIndex";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("getClosestIndex", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isArray()
        ) /* type: QList < RVector > */
    
    ){
    // prepare arguments:
    
                    // argument isArray
                    QList < RVector >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
    // end of arguments

    // call C++ function:
    // return type 'int'
    int cppResult =
        
               self->getClosestIndex(a0);
        // return type: int
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isArray()
        ) /* type: QList < RVector > */
     && (
            context->argument(1).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isArray
                    QList < RVector >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
                    // argument isStandardType
                    bool
                    a1 =
                    (bool)
                    
                    context->argument( 1 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'int'
    int cppResult =
        
               self->getClosestIndex(a0
        ,
    a1);
        // return type: int
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getClosestIndex().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getClosestIndex", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getClosestIndex2D
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getClosestIndex2D", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getClosestIndex2D";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("getClosestIndex2D", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isArray()
        ) /* type: QList < RVector > */
    
    ){
    // prepare arguments:
    
                    // argument isArray
                    QList < RVector >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
    // end of arguments

    // call C++ function:
    // return type 'int'
    int cppResult =
        
               self->getClosestIndex2D(a0);
        // return type: int
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getClosestIndex2D().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getClosestIndex2D", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::operator_add
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::operator +", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::operator +";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("operator +", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->operator +(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.operator_add().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::operator +", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::operator_subtract
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::operator -", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::operator -";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("operator -", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->operator -(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->operator -();
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.operator_subtract().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::operator -", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::operator_multiply
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::operator *", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::operator *";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("operator *", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->operator *(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.operator_multiply().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::operator *", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::operator_divide
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::operator /", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::operator /";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("operator /", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->operator /(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.operator_divide().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::operator /", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getNegated
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getNegated", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getNegated";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("getNegated", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->getNegated();
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getNegated().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getNegated", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getAbsolute
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getAbsolute", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getAbsolute";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("getAbsolute", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->getAbsolute();
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getAbsolute().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getAbsolute", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::dot
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::dot", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::dot";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("dot", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'double'
    double cppResult =
        
               self->dot(a0);
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.dot().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::dot", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::normalize
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::normalize", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::normalize";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("normalize", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->normalize();
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.normalize().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::normalize", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getNormalized
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getNormalized", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getNormalized";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("getNormalized", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->getNormalized();
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getNormalized().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getNormalized", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::operator_add_assign
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::operator +=", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::operator +=";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("operator +=", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->operator +=(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.operator_add_assign().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::operator +=", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::operator_subtract_assign
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::operator -=", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::operator -=";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("operator -=", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->operator -=(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.operator_subtract_assign().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::operator -=", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::operator_multiply_assign
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::operator *=", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::operator *=";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("operator *=", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->operator *=(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.operator_multiply_assign().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::operator *=", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::operator_divide_assign
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::operator /=", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::operator /=";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("operator /=", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->operator /=(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.operator_divide_assign().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::operator /=", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::equals
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::operator ==", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::operator ==";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("operator ==", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->operator ==(a0);
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.equals().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::operator ==", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::operator_not_assign
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::operator !=", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::operator !=";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("operator !=", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->operator !=(a0);
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.operator_not_assign().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::operator !=", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getFloor
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getFloor", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getFloor";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("getFloor", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->getFloor();
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getFloor().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getFloor", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getCeil
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getCeil", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getCeil";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("getCeil", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->getCeil();
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getCeil().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getCeil", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::lteXY
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::lteXY", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::lteXY";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("lteXY", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->lteXY(a0);
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.lteXY().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::lteXY", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::gteXY
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::gteXY", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::gteXY";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RVector* self = 
                        getSelf("gteXY", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->gteXY(a0);
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.gteXY().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::gteXY", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::containsFuzzy
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::containsFuzzy", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::containsFuzzy";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isArray()
        ) /* type: QList < RVector > */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isArray
                    QList < RVector >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap1 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 1 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a1 = 
                    *ap1;
                
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        RVector::
       containsFuzzy(a0
        ,
    a1);
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    3 && (
            context->argument(0).isArray()
        ) /* type: QList < RVector > */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RVector */
     && (
            context->argument(2).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isArray
                    QList < RVector >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap1 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 1 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a1 = 
                    *ap1;
                
                    // argument isStandardType
                    double
                    a2 =
                    (double)
                    
                    context->argument( 2 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        RVector::
       containsFuzzy(a0
        ,
    a1
        ,
    a2);
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.containsFuzzy().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::containsFuzzy", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::findFirstFuzzy
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::findFirstFuzzy", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::findFirstFuzzy";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isArray()
        ) /* type: QList < RVector > */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isArray
                    QList < RVector >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap1 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 1 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a1 = 
                    *ap1;
                
    // end of arguments

    // call C++ function:
    // return type 'int'
    int cppResult =
        RVector::
       findFirstFuzzy(a0
        ,
    a1);
        // return type: int
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    3 && (
            context->argument(0).isArray()
        ) /* type: QList < RVector > */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RVector */
     && (
            context->argument(2).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isArray
                    QList < RVector >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap1 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 1 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a1 = 
                    *ap1;
                
                    // argument isStandardType
                    double
                    a2 =
                    (double)
                    
                    context->argument( 2 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'int'
    int cppResult =
        RVector::
       findFirstFuzzy(a0
        ,
    a1
        ,
    a2);
        // return type: int
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.findFirstFuzzy().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::findFirstFuzzy", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getMinimum
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getMinimum", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getMinimum";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isArray()
        ) /* type: QList < RVector > */
    
    ){
    // prepare arguments:
    
                    // argument isArray
                    QList < RVector >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        RVector::
       getMinimum(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap1 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 1 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a1 = 
                    *ap1;
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        RVector::
       getMinimum(a0
        ,
    a1);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getMinimum().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getMinimum", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getMaximum
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getMaximum", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getMaximum";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isArray()
        ) /* type: QList < RVector > */
    
    ){
    // prepare arguments:
    
                    // argument isArray
                    QList < RVector >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        RVector::
       getMaximum(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap1 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 1 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a1 = 
                    *ap1;
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        RVector::
       getMaximum(a0
        ,
    a1);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getMaximum().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getMaximum", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getMinimumX
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getMinimumX", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getMinimumX";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isArray()
        ) /* type: QList < RVector > */
    
    ){
    // prepare arguments:
    
                    // argument isArray
                    QList < RVector >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        RVector::
       getMinimumX(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getMinimumX().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getMinimumX", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getMaximumX
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getMaximumX", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getMaximumX";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isArray()
        ) /* type: QList < RVector > */
    
    ){
    // prepare arguments:
    
                    // argument isArray
                    QList < RVector >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        RVector::
       getMaximumX(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getMaximumX().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getMaximumX", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getMinimumY
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getMinimumY", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getMinimumY";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isArray()
        ) /* type: QList < RVector > */
    
    ){
    // prepare arguments:
    
                    // argument isArray
                    QList < RVector >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        RVector::
       getMinimumY(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getMinimumY().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getMinimumY", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getMaximumY
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getMaximumY", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getMaximumY";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isArray()
        ) /* type: QList < RVector > */
    
    ){
    // prepare arguments:
    
                    // argument isArray
                    QList < RVector >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        RVector::
       getMaximumY(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getMaximumY().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getMaximumY", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getAverage
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getAverage", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getAverage";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap1 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 1 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a1 = 
                    *ap1;
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        RVector::
       getAverage(a0
        ,
    a1);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isArray()
        ) /* type: QList < RVector > */
    
    ){
    // prepare arguments:
    
                    // argument isArray
                    QList < RVector >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        RVector::
       getAverage(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getAverage().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getAverage", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getUnion
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getUnion", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getUnion";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isArray()
        ) /* type: QList < RVector > */
     && (
            context->argument(1).isArray()
        ) /* type: QList < RVector > */
    
    ){
    // prepare arguments:
    
                    // argument isArray
                    QList < RVector >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
                    // argument isArray
                    QList < RVector >
                    a1;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(1),
                        a1
                    );
                
    // end of arguments

    // call C++ function:
    // return type 'QList < RVector >'
    QList < RVector > cppResult =
        RVector::
       getUnion(a0
        ,
    a1);
        // return type: QList < RVector >
                // List of ...:
                result = REcmaHelper::listToScriptValue(engine, cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    3 && (
            context->argument(0).isArray()
        ) /* type: QList < RVector > */
     && (
            context->argument(1).isArray()
        ) /* type: QList < RVector > */
     && (
            context->argument(2).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isArray
                    QList < RVector >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
                    // argument isArray
                    QList < RVector >
                    a1;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(1),
                        a1
                    );
                
                    // argument isStandardType
                    double
                    a2 =
                    (double)
                    
                    context->argument( 2 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'QList < RVector >'
    QList < RVector > cppResult =
        RVector::
       getUnion(a0
        ,
    a1
        ,
    a2);
        // return type: QList < RVector >
                // List of ...:
                result = REcmaHelper::listToScriptValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getUnion().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getUnion", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getUnique
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getUnique", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getUnique";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isArray()
        ) /* type: QList < RVector > */
    
    ){
    // prepare arguments:
    
                    // argument isArray
                    QList < RVector >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
    // end of arguments

    // call C++ function:
    // return type 'QList < RVector >'
    QList < RVector > cppResult =
        RVector::
       getUnique(a0);
        // return type: QList < RVector >
                // List of ...:
                result = REcmaHelper::listToScriptValue(engine, cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isArray()
        ) /* type: QList < RVector > */
     && (
            context->argument(1).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isArray
                    QList < RVector >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
                    // argument isStandardType
                    double
                    a1 =
                    (double)
                    
                    context->argument( 1 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'QList < RVector >'
    QList < RVector > cppResult =
        RVector::
       getUnique(a0
        ,
    a1);
        // return type: QList < RVector >
                // List of ...:
                result = REcmaHelper::listToScriptValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getUnique().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getUnique", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getXList
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getXList", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getXList";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isArray()
        ) /* type: QList < RVector > */
    
    ){
    // prepare arguments:
    
                    // argument isArray
                    QList < RVector >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
    // end of arguments

    // call C++ function:
    // return type 'QList < double >'
    QList < double > cppResult =
        RVector::
       getXList(a0);
        // return type: QList < double >
                // List of ...:
                result = REcmaHelper::listToScriptValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getXList().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getXList", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getYList
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getYList", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getYList";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isArray()
        ) /* type: QList < RVector > */
    
    ){
    // prepare arguments:
    
                    // argument isArray
                    QList < RVector >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
    // end of arguments

    // call C++ function:
    // return type 'QList < double >'
    QList < double > cppResult =
        RVector::
       getYList(a0);
        // return type: QList < double >
                // List of ...:
                result = REcmaHelper::listToScriptValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getYList().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getYList", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getZList
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getZList", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getZList";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isArray()
        ) /* type: QList < RVector > */
    
    ){
    // prepare arguments:
    
                    // argument isArray
                    QList < RVector >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
    // end of arguments

    // call C++ function:
    // return type 'QList < double >'
    QList < double > cppResult =
        RVector::
       getZList(a0);
        // return type: QList < double >
                // List of ...:
                result = REcmaHelper::listToScriptValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getZList().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getZList", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getCrossProduct
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getCrossProduct", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getCrossProduct";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap1 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 1 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a1 = 
                    *ap1;
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        RVector::
       getCrossProduct(a0
        ,
    a1);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getCrossProduct().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getCrossProduct", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getDotProduct
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getDotProduct", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getDotProduct";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap1 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 1 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a1 = 
                    *ap1;
                
    // end of arguments

    // call C++ function:
    // return type 'double'
    double cppResult =
        RVector::
       getDotProduct(a0
        ,
    a1);
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getDotProduct().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getDotProduct", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::createPolar
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::createPolar", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::createPolar";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isNumber()
        ) /* type: double */
     && (
            context->argument(1).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
                    // argument isStandardType
                    double
                    a1 =
                    (double)
                    
                    context->argument( 1 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        RVector::
       createPolar(a0
        ,
    a1);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.createPolar().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::createPolar", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::lessThanX
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::lessThanX", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::lessThanX";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap1 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 1 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a1 = 
                    *ap1;
                
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        RVector::
       lessThanX(a0
        ,
    a1);
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.lessThanX().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::lessThanX", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::greaterThanX
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::greaterThanX", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::greaterThanX";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap1 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 1 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a1 = 
                    *ap1;
                
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        RVector::
       greaterThanX(a0
        ,
    a1);
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.greaterThanX().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::greaterThanX", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::lessThanY
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::lessThanY", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::lessThanY";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap1 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 1 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a1 = 
                    *ap1;
                
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        RVector::
       lessThanY(a0
        ,
    a1);
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.lessThanY().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::lessThanY", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::greaterThanY
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::greaterThanY", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::greaterThanY";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap1 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 1 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a1 = 
                    *ap1;
                
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        RVector::
       greaterThanY(a0
        ,
    a1);
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.greaterThanY().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::greaterThanY", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::lessThanEqualXY
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::lessThanEqualXY", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::lessThanEqualXY";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap1 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 1 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a1 = 
                    *ap1;
                
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        RVector::
       lessThanEqualXY(a0
        ,
    a1);
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.lessThanEqualXY().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::lessThanEqualXY", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::greaterThanEqualXY
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::greaterThanEqualXY", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::greaterThanEqualXY";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap1 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 1 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a1 = 
                    *ap1;
                
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        RVector::
       greaterThanEqualXY(a0
        ,
    a1);
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.greaterThanEqualXY().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::greaterThanEqualXY", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getSortedByDistance
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getSortedByDistance", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getSortedByDistance";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isArray()
        ) /* type: QList < RVector > */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isArray
                    QList < RVector >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap1 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 1 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a1 = 
                    *ap1;
                
    // end of arguments

    // call C++ function:
    // return type 'QList < RVector >'
    QList < RVector > cppResult =
        RVector::
       getSortedByDistance(a0
        ,
    a1);
        // return type: QList < RVector >
                // List of ...:
                result = REcmaHelper::listToScriptValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getSortedByDistance().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getSortedByDistance", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getSortedLeftRightTopBottom
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getSortedLeftRightTopBottom", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getSortedLeftRightTopBottom";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isArray()
        ) /* type: QList < RVector > */
    
    ){
    // prepare arguments:
    
                    // argument isArray
                    QList < RVector >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
    // end of arguments

    // call C++ function:
    // return type 'QList < RVector >'
    QList < RVector > cppResult =
        RVector::
       getSortedLeftRightTopBottom(a0);
        // return type: QList < RVector >
                // List of ...:
                result = REcmaHelper::listToScriptValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getSortedLeftRightTopBottom().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getSortedLeftRightTopBottom", context, engine);
            return result;
        }
         QScriptValue
        REcmaVector::getSortedByAngle
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaVector::getSortedByAngle", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaVector::getSortedByAngle";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
    
    if( context->argumentCount() ==
    3 && (
            context->argument(0).isArray()
        ) /* type: QList < RVector > */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RVector */
     && (
            context->argument(2).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isArray
                    QList < RVector >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap1 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RVector: Argument 1 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a1 = 
                    *ap1;
                
                    // argument isStandardType
                    double
                    a2 =
                    (double)
                    
                    context->argument( 2 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'QList < RVector >'
    QList < RVector > cppResult =
        RVector::
       getSortedByAngle(a0
        ,
    a1
        ,
    a2);
        // return type: QList < RVector >
                // List of ...:
                result = REcmaHelper::listToScriptValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RVector.getSortedByAngle().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaVector::getSortedByAngle", context, engine);
            return result;
        }
         QScriptValue REcmaVector::toString
    (QScriptContext *context, QScriptEngine *engine)
    
    {

    RVector* self = getSelf("toString", context);
    
    QString result;
    
            QDebug d(&result);
            if (self!=NULL) {
                d << *self;
            }
            else {
                d << "NULL";
            }
        
    return QScriptValue(result);
    }
     QScriptValue REcmaVector::copy
    (QScriptContext *context, QScriptEngine *engine)
    
    {
        RVector cp = qscriptvalue_cast<RVector>(context->thisObject());
        return qScriptValueFromValue(engine, cp);
    }
     QScriptValue REcmaVector::destroy(QScriptContext *context, QScriptEngine *engine)
    
    {

        RVector* self = getSelf("RVector", context);
        //Q_ASSERT(self!=NULL);
        if (self==NULL) {
            return REcmaHelper::throwError("self is NULL", context);
        }
        
    
        delete self;
        context->thisObject().setData(engine->nullValue());
        context->thisObject().prototype().setData(engine->nullValue());
        context->thisObject().setPrototype(engine->nullValue());
        context->thisObject().setScriptClass(NULL);
        return engine->undefinedValue();
    }
    RVector* REcmaVector::getSelf(const QString& fName, QScriptContext* context)
    
        {
            RVector* self = NULL;

            
                // self could be a normal object (e.g. from an UI file) or
                // an ECMA shell object (made from an ECMA script):
                //self = getSelfShell(fName, context);
                

            //if (self==NULL) {
                self = REcmaHelper::scriptValueTo<RVector >(context->thisObject())
                
                ;
            //}

            if (self == NULL){
                // avoid recursion (toString is used by the backtrace):
                if (fName!="toString") {
                    REcmaHelper::throwError(QString("RVector.%1(): "
                        "This object is not a RVector").arg(fName),
                        context);
                }
                return NULL;
            }

            return self;
        }
        RVector* REcmaVector::getSelfShell(const QString& fName, QScriptContext* context)
    
        {
          RVector* selfBase = getSelf(fName, context);
                RVector* self = dynamic_cast<RVector*>(selfBase);
                //return REcmaHelper::scriptValueTo<RVector >(context->thisObject());
            if(self == NULL){
                REcmaHelper::throwError(QString("RVector.%1(): "
                    "This object is not a RVector").arg(fName),
                    context);
            }

            return self;
            


        }
        