// ***** AUTOGENERATED CODE, DO NOT EDIT *****
            // ***** This class is not copyable.
        
        #include "REcmaDocumentInterface.h"
        #include "RMetaTypes.h"
        #include "../REcmaHelper.h"

        // forwards declarations mapped to includes
        
                #include "RGraphicsScene.h"
            
                #include "RGraphicsSceneDrawable.h"
            
                #include "RGraphicsView.h"
            
                #include "RMouseEvent.h"
            
                #include "ROperation.h"
            
                #include "RPropertyEvent.h"
            
                #include "RSnap.h"
            
                #include "RSnapRestriction.h"
            
                #include "RScriptHandler.h"
            
                #include "RTransaction.h"
            
                #include "RWheelEvent.h"
            
            
        // includes for base ecma wrapper classes
         void REcmaDocumentInterface::initEcma(QScriptEngine& engine, QScriptValue* proto 
    
    ) 
    
    {

    bool protoCreated = false;
    if(proto == NULL){
        proto = new QScriptValue(engine.newVariant(qVariantFromValue(
                (RDocumentInterface*) 0)));
        protoCreated = true;
    }

    

    QScriptValue fun;

    // toString:
    REcmaHelper::registerFunction(&engine, proto, toString, "toString");
    

    // destroy:
    REcmaHelper::registerFunction(&engine, proto, destroy, "destroy");
    

    // get class name
    REcmaHelper::registerFunction(&engine, proto, getClassName, "getClassName");
    

    // conversion to all base classes (multiple inheritance):
    REcmaHelper::registerFunction(&engine, proto, getBaseClasses, "getBaseClasses");
    

    // properties:
    

    // methods:
    
            REcmaHelper::registerFunction(&engine, proto, clearCaches, "clearCaches");
            
            REcmaHelper::registerFunction(&engine, proto, getDocument, "getDocument");
            
            REcmaHelper::registerFunction(&engine, proto, getStorage, "getStorage");
            
            REcmaHelper::registerFunction(&engine, proto, getGraphicsScenes, "getGraphicsScenes");
            
            REcmaHelper::registerFunction(&engine, proto, getGraphicsViewWithFocus, "getGraphicsViewWithFocus");
            
            REcmaHelper::registerFunction(&engine, proto, getGraphicsSceneWithFocus, "getGraphicsSceneWithFocus");
            
            REcmaHelper::registerFunction(&engine, proto, addCoordinateListener, "addCoordinateListener");
            
            REcmaHelper::registerFunction(&engine, proto, notifyCoordinateListeners, "notifyCoordinateListeners");
            
            REcmaHelper::registerFunction(&engine, proto, addLayerListener, "addLayerListener");
            
            REcmaHelper::registerFunction(&engine, proto, removeLayerListener, "removeLayerListener");
            
            REcmaHelper::registerFunction(&engine, proto, notifyLayerListeners, "notifyLayerListeners");
            
            REcmaHelper::registerFunction(&engine, proto, addTransactionListener, "addTransactionListener");
            
            REcmaHelper::registerFunction(&engine, proto, removeTransactionListener, "removeTransactionListener");
            
            REcmaHelper::registerFunction(&engine, proto, notifyTransactionListeners, "notifyTransactionListeners");
            
            REcmaHelper::registerFunction(&engine, proto, clear, "clear");
            
            REcmaHelper::registerFunction(&engine, proto, getScriptHandler, "getScriptHandler");
            
            REcmaHelper::registerFunction(&engine, proto, isScriptRunning, "isScriptRunning");
            
            REcmaHelper::registerFunction(&engine, proto, setDefaultAction, "setDefaultAction");
            
            REcmaHelper::registerFunction(&engine, proto, getDefaultAction, "getDefaultAction");
            
            REcmaHelper::registerFunction(&engine, proto, setCurrentAction, "setCurrentAction");
            
            REcmaHelper::registerFunction(&engine, proto, terminateCurrentAction, "terminateCurrentAction");
            
            REcmaHelper::registerFunction(&engine, proto, queueAction, "queueAction");
            
            REcmaHelper::registerFunction(&engine, proto, killAllActions, "killAllActions");
            
            REcmaHelper::registerFunction(&engine, proto, getCurrentAction, "getCurrentAction");
            
            REcmaHelper::registerFunction(&engine, proto, hasCurrentAction, "hasCurrentAction");
            
            REcmaHelper::registerFunction(&engine, proto, getCurrentStatefulAction, "getCurrentStatefulAction");
            
            REcmaHelper::registerFunction(&engine, proto, hasCurrentStatefulAction, "hasCurrentStatefulAction");
            
            REcmaHelper::registerFunction(&engine, proto, suspend, "suspend");
            
            REcmaHelper::registerFunction(&engine, proto, resume, "resume");
            
            REcmaHelper::registerFunction(&engine, proto, setClickMode, "setClickMode");
            
            REcmaHelper::registerFunction(&engine, proto, getClickMode, "getClickMode");
            
            REcmaHelper::registerFunction(&engine, proto, terminateEvent, "terminateEvent");
            
            REcmaHelper::registerFunction(&engine, proto, keyPressEvent, "keyPressEvent");
            
            REcmaHelper::registerFunction(&engine, proto, keyReleaseEvent, "keyReleaseEvent");
            
            REcmaHelper::registerFunction(&engine, proto, mouseMoveEvent, "mouseMoveEvent");
            
            REcmaHelper::registerFunction(&engine, proto, mousePressEvent, "mousePressEvent");
            
            REcmaHelper::registerFunction(&engine, proto, mouseReleaseEvent, "mouseReleaseEvent");
            
            REcmaHelper::registerFunction(&engine, proto, mouseDoubleClickEvent, "mouseDoubleClickEvent");
            
            REcmaHelper::registerFunction(&engine, proto, coordinateEvent, "coordinateEvent");
            
            REcmaHelper::registerFunction(&engine, proto, coordinateEventPreview, "coordinateEventPreview");
            
            REcmaHelper::registerFunction(&engine, proto, commandEvent, "commandEvent");
            
            REcmaHelper::registerFunction(&engine, proto, commandEventPreview, "commandEventPreview");
            
            REcmaHelper::registerFunction(&engine, proto, wheelEvent, "wheelEvent");
            
            REcmaHelper::registerFunction(&engine, proto, tabletEvent, "tabletEvent");
            
            REcmaHelper::registerFunction(&engine, proto, swipeGestureEvent, "swipeGestureEvent");
            
            REcmaHelper::registerFunction(&engine, proto, panGestureEvent, "panGestureEvent");
            
            REcmaHelper::registerFunction(&engine, proto, pinchGestureEvent, "pinchGestureEvent");
            
            REcmaHelper::registerFunction(&engine, proto, propertyChangeEvent, "propertyChangeEvent");
            
            REcmaHelper::registerFunction(&engine, proto, ucsSetEvent, "ucsSetEvent");
            
            REcmaHelper::registerFunction(&engine, proto, zoomChangeEvent, "zoomChangeEvent");
            
            REcmaHelper::registerFunction(&engine, proto, enableUpdates, "enableUpdates");
            
            REcmaHelper::registerFunction(&engine, proto, disableUpdates, "disableUpdates");
            
            REcmaHelper::registerFunction(&engine, proto, enableRegeneration, "enableRegeneration");
            
            REcmaHelper::registerFunction(&engine, proto, disableRegeneration, "disableRegeneration");
            
            REcmaHelper::registerFunction(&engine, proto, enableMouseTracking, "enableMouseTracking");
            
            REcmaHelper::registerFunction(&engine, proto, disableMouseTracking, "disableMouseTracking");
            
            REcmaHelper::registerFunction(&engine, proto, updateAllEntities, "updateAllEntities");
            
            REcmaHelper::registerFunction(&engine, proto, regenerateScenes, "regenerateScenes");
            
            REcmaHelper::registerFunction(&engine, proto, updateSelectionStatus, "updateSelectionStatus");
            
            REcmaHelper::registerFunction(&engine, proto, regenerateViews, "regenerateViews");
            
            REcmaHelper::registerFunction(&engine, proto, repaintViews, "repaintViews");
            
            REcmaHelper::registerFunction(&engine, proto, registerScene, "registerScene");
            
            REcmaHelper::registerFunction(&engine, proto, unregisterScene, "unregisterScene");
            
            REcmaHelper::registerFunction(&engine, proto, setCursor, "setCursor");
            
            REcmaHelper::registerFunction(&engine, proto, importUrl, "importUrl");
            
            REcmaHelper::registerFunction(&engine, proto, importFile, "importFile");
            
            REcmaHelper::registerFunction(&engine, proto, getCorrectedFileName, "getCorrectedFileName");
            
            REcmaHelper::registerFunction(&engine, proto, exportFile, "exportFile");
            
            REcmaHelper::registerFunction(&engine, proto, tagState, "tagState");
            
            REcmaHelper::registerFunction(&engine, proto, undoToTag, "undoToTag");
            
            REcmaHelper::registerFunction(&engine, proto, undo, "undo");
            
            REcmaHelper::registerFunction(&engine, proto, redo, "redo");
            
            REcmaHelper::registerFunction(&engine, proto, flushTransactions, "flushTransactions");
            
            REcmaHelper::registerFunction(&engine, proto, flushRedo, "flushRedo");
            
            REcmaHelper::registerFunction(&engine, proto, setSnap, "setSnap");
            
            REcmaHelper::registerFunction(&engine, proto, getSnap, "getSnap");
            
            REcmaHelper::registerFunction(&engine, proto, setSnapRestriction, "setSnapRestriction");
            
            REcmaHelper::registerFunction(&engine, proto, getSnapRestriction, "getSnapRestriction");
            
            REcmaHelper::registerFunction(&engine, proto, snap, "snap");
            
            REcmaHelper::registerFunction(&engine, proto, restrictOrtho, "restrictOrtho");
            
            REcmaHelper::registerFunction(&engine, proto, getClosestEntity, "getClosestEntity");
            
            REcmaHelper::registerFunction(&engine, proto, highlightEntity, "highlightEntity");
            
            REcmaHelper::registerFunction(&engine, proto, highlightReferencePoint, "highlightReferencePoint");
            
            REcmaHelper::registerFunction(&engine, proto, selectEntities, "selectEntities");
            
            REcmaHelper::registerFunction(&engine, proto, selectEntity, "selectEntity");
            
            REcmaHelper::registerFunction(&engine, proto, deselectEntities, "deselectEntities");
            
            REcmaHelper::registerFunction(&engine, proto, deselectEntity, "deselectEntity");
            
            REcmaHelper::registerFunction(&engine, proto, selectBoxXY, "selectBoxXY");
            
            REcmaHelper::registerFunction(&engine, proto, selectAll, "selectAll");
            
            REcmaHelper::registerFunction(&engine, proto, deselectAll, "deselectAll");
            
            REcmaHelper::registerFunction(&engine, proto, clearSelection, "clearSelection");
            
            REcmaHelper::registerFunction(&engine, proto, hasSelection, "hasSelection");
            
            REcmaHelper::registerFunction(&engine, proto, addZoomBoxToPreview, "addZoomBoxToPreview");
            
            REcmaHelper::registerFunction(&engine, proto, addShapeToPreview, "addShapeToPreview");
            
            REcmaHelper::registerFunction(&engine, proto, addAuxShapeToPreview, "addAuxShapeToPreview");
            
            REcmaHelper::registerFunction(&engine, proto, addEntityToPreview, "addEntityToPreview");
            
            REcmaHelper::registerFunction(&engine, proto, addDrawableToPreview, "addDrawableToPreview");
            
            REcmaHelper::registerFunction(&engine, proto, beginPreview, "beginPreview");
            
            REcmaHelper::registerFunction(&engine, proto, endPreview, "endPreview");
            
            REcmaHelper::registerFunction(&engine, proto, clearPreview, "clearPreview");
            
            REcmaHelper::registerFunction(&engine, proto, isPreviewEmpty, "isPreviewEmpty");
            
            REcmaHelper::registerFunction(&engine, proto, keepPreview, "keepPreview");
            
            REcmaHelper::registerFunction(&engine, proto, showPropertiesOf, "showPropertiesOf");
            
            REcmaHelper::registerFunction(&engine, proto, clearProperties, "clearProperties");
            
            REcmaHelper::registerFunction(&engine, proto, zoomIn, "zoomIn");
            
            REcmaHelper::registerFunction(&engine, proto, zoomOut, "zoomOut");
            
            REcmaHelper::registerFunction(&engine, proto, autoZoom, "autoZoom");
            
            REcmaHelper::registerFunction(&engine, proto, zoomToSelection, "zoomToSelection");
            
            REcmaHelper::registerFunction(&engine, proto, zoomTo, "zoomTo");
            
            REcmaHelper::registerFunction(&engine, proto, zoomPrevious, "zoomPrevious");
            
            REcmaHelper::registerFunction(&engine, proto, previewOperation, "previewOperation");
            
            REcmaHelper::registerFunction(&engine, proto, applyOperation, "applyOperation");
            
            REcmaHelper::registerFunction(&engine, proto, objectChangeEvent, "objectChangeEvent");
            
            REcmaHelper::registerFunction(&engine, proto, getRelativeZero, "getRelativeZero");
            
            REcmaHelper::registerFunction(&engine, proto, getLastPosition, "getLastPosition");
            
            REcmaHelper::registerFunction(&engine, proto, setRelativeZero, "setRelativeZero");
            
            REcmaHelper::registerFunction(&engine, proto, lockRelativeZero, "lockRelativeZero");
            
            REcmaHelper::registerFunction(&engine, proto, unlockRelativeZero, "unlockRelativeZero");
            
            REcmaHelper::registerFunction(&engine, proto, isRelativeZeroLocked, "isRelativeZeroLocked");
            
            REcmaHelper::registerFunction(&engine, proto, lockSnap, "lockSnap");
            
            REcmaHelper::registerFunction(&engine, proto, unlockSnap, "unlockSnap");
            
            REcmaHelper::registerFunction(&engine, proto, toggleSnapLock, "toggleSnapLock");
            
            REcmaHelper::registerFunction(&engine, proto, isSnapLocked, "isSnapLocked");
            
            REcmaHelper::registerFunction(&engine, proto, getCursorPosition, "getCursorPosition");
            
            REcmaHelper::registerFunction(&engine, proto, setCursorPosition, "setCursorPosition");
            
            REcmaHelper::registerFunction(&engine, proto, setCursorOverride, "setCursorOverride");
            
            REcmaHelper::registerFunction(&engine, proto, getCursorOverride, "getCursorOverride");
            
            REcmaHelper::registerFunction(&engine, proto, deleteTerminatedActions, "deleteTerminatedActions");
            
            REcmaHelper::registerFunction(&engine, proto, setCurrentColor, "setCurrentColor");
            
            REcmaHelper::registerFunction(&engine, proto, getCurrentColor, "getCurrentColor");
            
            REcmaHelper::registerFunction(&engine, proto, setCurrentLineweight, "setCurrentLineweight");
            
            REcmaHelper::registerFunction(&engine, proto, getCurrentLineweight, "getCurrentLineweight");
            
            REcmaHelper::registerFunction(&engine, proto, setCurrentLinetype, "setCurrentLinetype");
            
            REcmaHelper::registerFunction(&engine, proto, setCurrentLinetypePattern, "setCurrentLinetypePattern");
            
            REcmaHelper::registerFunction(&engine, proto, getCurrentLinetypeId, "getCurrentLinetypeId");
            
            REcmaHelper::registerFunction(&engine, proto, getCurrentLinetypePattern, "getCurrentLinetypePattern");
            
            REcmaHelper::registerFunction(&engine, proto, setCurrentLayer, "setCurrentLayer");
            
            REcmaHelper::registerFunction(&engine, proto, setCurrentBlock, "setCurrentBlock");
            
            REcmaHelper::registerFunction(&engine, proto, setCurrentViewport, "setCurrentViewport");
            
            REcmaHelper::registerFunction(&engine, proto, unsetCurrentViewport, "unsetCurrentViewport");
            
            REcmaHelper::registerFunction(&engine, proto, setCurrentView, "setCurrentView");
            
            REcmaHelper::registerFunction(&engine, proto, setCurrentUcs, "setCurrentUcs");
            
            REcmaHelper::registerFunction(&engine, proto, getCurrentUcs, "getCurrentUcs");
            
            REcmaHelper::registerFunction(&engine, proto, getCurrentUcsName, "getCurrentUcsName");
            
            REcmaHelper::registerFunction(&engine, proto, getLastKnownViewWithFocus, "getLastKnownViewWithFocus");
            
            REcmaHelper::registerFunction(&engine, proto, setLastKnownViewWithFocus, "setLastKnownViewWithFocus");
            
            REcmaHelper::registerFunction(&engine, proto, isClipboard, "isClipboard");
            
            REcmaHelper::registerFunction(&engine, proto, isSuspended, "isSuspended");
            
            REcmaHelper::registerFunction(&engine, proto, setNotifyListeners, "setNotifyListeners");
            
            REcmaHelper::registerFunction(&engine, proto, getNotifyListeners, "getNotifyListeners");
            
            REcmaHelper::registerFunction(&engine, proto, isDeleting, "isDeleting");
            
            REcmaHelper::registerFunction(&engine, proto, eval, "eval");
            
        engine.setDefaultPrototype(
            qMetaTypeId<RDocumentInterface*>(), *proto);

        
    

    QScriptValue ctor = engine.newFunction(createEcma, *proto, 2);
    
    // static methods:
    
            REcmaHelper::registerFunction(&engine, &ctor, getClipboard, "getClipboard");
            
            REcmaHelper::registerFunction(&engine, &ctor, deleteClipboard, "deleteClipboard");
            

    // static properties:
    

    // enum values:
    

    ctor.setProperty("IoErrorNoError",
    QScriptValue(RDocumentInterface::IoErrorNoError),
    QScriptValue::ReadOnly);


    ctor.setProperty("IoErrorNoImporterFound",
    QScriptValue(RDocumentInterface::IoErrorNoImporterFound),
    QScriptValue::ReadOnly);


    ctor.setProperty("IoErrorZeroSize",
    QScriptValue(RDocumentInterface::IoErrorZeroSize),
    QScriptValue::ReadOnly);


    ctor.setProperty("IoErrorNotFound",
    QScriptValue(RDocumentInterface::IoErrorNotFound),
    QScriptValue::ReadOnly);


    ctor.setProperty("IoErrorPermission",
    QScriptValue(RDocumentInterface::IoErrorPermission),
    QScriptValue::ReadOnly);


    ctor.setProperty("IoErrorGeneralImportError",
    QScriptValue(RDocumentInterface::IoErrorGeneralImportError),
    QScriptValue::ReadOnly);


    ctor.setProperty("IoErrorGeneralImportUrlError",
    QScriptValue(RDocumentInterface::IoErrorGeneralImportUrlError),
    QScriptValue::ReadOnly);


    // enum conversions:
    
    qScriptRegisterMetaType<RDocumentInterface::IoErrorCode>(
        &engine,
        toScriptValueEnumIoErrorCode,
        fromScriptValueEnumIoErrorCode,
        ctor.property(QString::fromLatin1("prototype"))
    );

        
    // init class:
    engine.globalObject().setProperty("RDocumentInterface",
    ctor, QScriptValue::SkipInEnumeration);
    
    if( protoCreated ){
       delete proto;
    }
    
    }
     QScriptValue REcmaDocumentInterface::createEcma(QScriptContext* context, QScriptEngine* engine) 
    
    {
    if (context->thisObject().strictlyEquals(
       engine->globalObject())) {
       return REcmaHelper::throwError(
       QString::fromLatin1("RDocumentInterface(): Did you forget to construct with 'new'?"),
           context);
    }

    QScriptValue result;
        
            // generate constructor variants:
            
    if( context->argumentCount() ==
        1
                && (
                
                        context->argument(
                        0
                        ).isVariant()
                        ||
                    
                        context->argument(
                        0
                        ).isQObject()
                        ||
                    
                        context->argument(
                        0
                        ).isNull()
                ) /* type: RDocument */
            
    ){
    // prepare arguments:
    
                    // argument is reference
                    RDocument*
                    ap0 =
                    qscriptvalue_cast<
                    RDocument*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RDocument*.",
                               context);                    
                    }
                    RDocument& a0 = *ap0;
                
    // end of arguments

    // call C++ constructor:
    
            // non-copyable class:
            RDocumentInterface
                    * cppResult =
                    new
                    RDocumentInterface
                    (
                    a0
                    );
                
                    // TODO: triggers: Warning: QScriptEngine::newVariant(): changing class of non-QScriptObject not supported:
                    result = engine->newVariant(context->thisObject(), qVariantFromValue(cppResult));
                
    } else 

    {
       return REcmaHelper::throwError(
       QString::fromLatin1("RDocumentInterface(): no matching constructor found."),
           context);
    }
    
    return result;
    }
    

    // conversion functions for base classes:
    

    // returns class name:
     QScriptValue REcmaDocumentInterface::getClassName(QScriptContext *context, QScriptEngine *engine) 
        
    {
        return qScriptValueFromValue(engine, QString("RDocumentInterface"));
    }
    

    // returns all base classes (in case of multiple inheritance):
     QScriptValue REcmaDocumentInterface::getBaseClasses(QScriptContext *context, QScriptEngine *engine) 
        
    {
        QStringList list;
        

        return qScriptValueFromSequence(engine, list);
    }
    

    // properties:
    

    // public methods:
     QScriptValue
        REcmaDocumentInterface::clearCaches
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::clearCaches", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::clearCaches";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("clearCaches", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->clearCaches();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.clearCaches().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::clearCaches", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::getDocument
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::getDocument", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::getDocument";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("getDocument", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RDocument &'
    RDocument & cppResult =
        
               self->getDocument();
        // return type: RDocument &
                // reference
                result = engine->newVariant(
                QVariant::fromValue(&cppResult));
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.getDocument().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::getDocument", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::getStorage
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::getStorage", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::getStorage";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("getStorage", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RStorage &'
    RStorage & cppResult =
        
               self->getStorage();
        // return type: RStorage &
                // reference
                result = engine->newVariant(
                QVariant::fromValue(&cppResult));
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.getStorage().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::getStorage", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::getGraphicsScenes
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::getGraphicsScenes", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::getGraphicsScenes";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("getGraphicsScenes", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'QList < RGraphicsScene * >'
    QList < RGraphicsScene * > cppResult =
        
               self->getGraphicsScenes();
        // return type: QList < RGraphicsScene * >
                // List of ...:
                result = REcmaHelper::listToScriptValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.getGraphicsScenes().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::getGraphicsScenes", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::getGraphicsViewWithFocus
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::getGraphicsViewWithFocus", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::getGraphicsViewWithFocus";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("getGraphicsViewWithFocus", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RGraphicsView *'
    RGraphicsView * cppResult =
        
               self->getGraphicsViewWithFocus();
        // return type: RGraphicsView *
                // RGraphicsView:
                result = REcmaHelper::toScriptValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.getGraphicsViewWithFocus().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::getGraphicsViewWithFocus", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::getGraphicsSceneWithFocus
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::getGraphicsSceneWithFocus", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::getGraphicsSceneWithFocus";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("getGraphicsSceneWithFocus", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RGraphicsScene *'
    RGraphicsScene * cppResult =
        
               self->getGraphicsSceneWithFocus();
        // return type: RGraphicsScene *
                // RGraphicsScene:
                result = REcmaHelper::toScriptValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.getGraphicsSceneWithFocus().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::getGraphicsSceneWithFocus", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::addCoordinateListener
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::addCoordinateListener", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::addCoordinateListener";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("addCoordinateListener", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RCoordinateListener * */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RCoordinateListener * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RCoordinateListener >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RCoordinateListener *RCoordinateListener *.", context);                    
                    }
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->addCoordinateListener(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.addCoordinateListener().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::addCoordinateListener", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::notifyCoordinateListeners
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::notifyCoordinateListeners", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::notifyCoordinateListeners";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("notifyCoordinateListeners", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->notifyCoordinateListeners();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.notifyCoordinateListeners().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::notifyCoordinateListeners", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::addLayerListener
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::addLayerListener", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::addLayerListener";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("addLayerListener", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RLayerListener * */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RLayerListener * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RLayerListener >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RLayerListener *RLayerListener *.", context);                    
                    }
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->addLayerListener(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.addLayerListener().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::addLayerListener", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::removeLayerListener
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::removeLayerListener", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::removeLayerListener";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("removeLayerListener", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RLayerListener * */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RLayerListener * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RLayerListener >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RLayerListener *RLayerListener *.", context);                    
                    }
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->removeLayerListener(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.removeLayerListener().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::removeLayerListener", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::notifyLayerListeners
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::notifyLayerListeners", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::notifyLayerListeners";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("notifyLayerListeners", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isArray()
        ) /* type: QList < RLayer::Id > */
    
    ){
    // prepare arguments:
    
                    // argument isArray
                    QList < RLayer::Id >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->notifyLayerListeners(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.notifyLayerListeners().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::notifyLayerListeners", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::addTransactionListener
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::addTransactionListener", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::addTransactionListener";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("addTransactionListener", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RTransactionListener * */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RTransactionListener * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RTransactionListener >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RTransactionListener *RTransactionListener *.", context);                    
                    }
                
    // end of arguments

    // call C++ function:
    // return type 'int'
    int cppResult =
        
               self->addTransactionListener(a0);
        // return type: int
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.addTransactionListener().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::addTransactionListener", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::removeTransactionListener
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::removeTransactionListener", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::removeTransactionListener";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("removeTransactionListener", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: int */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    int
                    a0 =
                    (int)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->removeTransactionListener(a0);
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RTransactionListener * */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RTransactionListener * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RTransactionListener >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RTransactionListener *RTransactionListener *.", context);                    
                    }
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->removeTransactionListener(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.removeTransactionListener().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::removeTransactionListener", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::notifyTransactionListeners
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::notifyTransactionListeners", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::notifyTransactionListeners";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("notifyTransactionListeners", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RTransaction * */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RTransaction * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RTransaction >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RTransaction *RTransaction *.", context);                    
                    }
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->notifyTransactionListeners(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.notifyTransactionListeners().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::notifyTransactionListeners", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::clear
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::clear", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::clear";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("clear", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->clear();
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->clear(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.clear().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::clear", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::getScriptHandler
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::getScriptHandler", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::getScriptHandler";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("getScriptHandler", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isString()
        ) /* type: QString */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    QString
                    a0 =
                    (QString)
                    
                    context->argument( 0 ).
                    toString();
                
    // end of arguments

    // call C++ function:
    // return type 'RScriptHandler *'
    RScriptHandler * cppResult =
        
               self->getScriptHandler(a0);
        // return type: RScriptHandler *
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.getScriptHandler().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::getScriptHandler", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::isScriptRunning
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::isScriptRunning", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::isScriptRunning";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("isScriptRunning", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->isScriptRunning();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.isScriptRunning().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::isScriptRunning", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::setDefaultAction
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::setDefaultAction", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::setDefaultAction";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("setDefaultAction", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RAction * */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RAction * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RAction >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RAction *RAction *.", context);                    
                    }
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setDefaultAction(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.setDefaultAction().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::setDefaultAction", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::getDefaultAction
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::getDefaultAction", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::getDefaultAction";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("getDefaultAction", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RAction *'
    RAction * cppResult =
        
               self->getDefaultAction();
        // return type: RAction *
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.getDefaultAction().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::getDefaultAction", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::setCurrentAction
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::setCurrentAction", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::setCurrentAction";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("setCurrentAction", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RAction * */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RAction * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RAction >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RAction *RAction *.", context);                    
                    }
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setCurrentAction(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.setCurrentAction().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::setCurrentAction", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::terminateCurrentAction
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::terminateCurrentAction", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::terminateCurrentAction";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("terminateCurrentAction", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->terminateCurrentAction();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.terminateCurrentAction().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::terminateCurrentAction", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::queueAction
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::queueAction", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::queueAction";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("queueAction", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RAction * */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RAction * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RAction >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RAction *RAction *.", context);                    
                    }
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->queueAction(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.queueAction().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::queueAction", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::killAllActions
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::killAllActions", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::killAllActions";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("killAllActions", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->killAllActions();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.killAllActions().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::killAllActions", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::getCurrentAction
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::getCurrentAction", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::getCurrentAction";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("getCurrentAction", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RAction *'
    RAction * cppResult =
        
               self->getCurrentAction();
        // return type: RAction *
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.getCurrentAction().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::getCurrentAction", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::hasCurrentAction
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::hasCurrentAction", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::hasCurrentAction";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("hasCurrentAction", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->hasCurrentAction();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.hasCurrentAction().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::hasCurrentAction", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::getCurrentStatefulAction
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::getCurrentStatefulAction", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::getCurrentStatefulAction";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("getCurrentStatefulAction", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RAction *'
    RAction * cppResult =
        
               self->getCurrentStatefulAction();
        // return type: RAction *
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.getCurrentStatefulAction().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::getCurrentStatefulAction", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::hasCurrentStatefulAction
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::hasCurrentStatefulAction", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::hasCurrentStatefulAction";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("hasCurrentStatefulAction", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->hasCurrentStatefulAction();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.hasCurrentStatefulAction().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::hasCurrentStatefulAction", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::suspend
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::suspend", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::suspend";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("suspend", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->suspend();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.suspend().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::suspend", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::resume
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::resume", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::resume";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("resume", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->resume();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.resume().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::resume", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::setClickMode
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::setClickMode", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::setClickMode";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("setClickMode", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: RAction::ClickMode */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    RAction::ClickMode
                    a0 =
                    (RAction::ClickMode)
                    (int)
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setClickMode(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.setClickMode().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::setClickMode", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::getClickMode
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::getClickMode", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::getClickMode";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("getClickMode", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RAction::ClickMode'
    RAction::ClickMode cppResult =
        
               self->getClickMode();
        // return type: RAction::ClickMode
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.getClickMode().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::getClickMode", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::terminateEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::terminateEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::terminateEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("terminateEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RTerminateEvent */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    RTerminateEvent*
                    ap0 =
                    qscriptvalue_cast<
                    RTerminateEvent*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RTerminateEvent*.",
                               context);                    
                    }
                    RTerminateEvent& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->terminateEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.terminateEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::terminateEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::keyPressEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::keyPressEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::keyPressEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("keyPressEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant()
        ) /* type: QKeyEvent */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    QKeyEvent*
                    ap0 =
                    qscriptvalue_cast<
                    QKeyEvent*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type QKeyEvent*.",
                               context);                    
                    }
                    QKeyEvent& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->keyPressEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.keyPressEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::keyPressEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::keyReleaseEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::keyReleaseEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::keyReleaseEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("keyReleaseEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant()
        ) /* type: QKeyEvent */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    QKeyEvent*
                    ap0 =
                    qscriptvalue_cast<
                    QKeyEvent*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type QKeyEvent*.",
                               context);                    
                    }
                    QKeyEvent& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->keyReleaseEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.keyReleaseEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::keyReleaseEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::mouseMoveEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::mouseMoveEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::mouseMoveEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("mouseMoveEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RMouseEvent */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    RMouseEvent*
                    ap0 =
                    qscriptvalue_cast<
                    RMouseEvent*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RMouseEvent*.",
                               context);                    
                    }
                    RMouseEvent& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->mouseMoveEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.mouseMoveEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::mouseMoveEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::mousePressEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::mousePressEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::mousePressEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("mousePressEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RMouseEvent */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    RMouseEvent*
                    ap0 =
                    qscriptvalue_cast<
                    RMouseEvent*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RMouseEvent*.",
                               context);                    
                    }
                    RMouseEvent& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->mousePressEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.mousePressEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::mousePressEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::mouseReleaseEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::mouseReleaseEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::mouseReleaseEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("mouseReleaseEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RMouseEvent */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    RMouseEvent*
                    ap0 =
                    qscriptvalue_cast<
                    RMouseEvent*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RMouseEvent*.",
                               context);                    
                    }
                    RMouseEvent& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->mouseReleaseEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.mouseReleaseEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::mouseReleaseEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::mouseDoubleClickEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::mouseDoubleClickEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::mouseDoubleClickEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("mouseDoubleClickEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RMouseEvent */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    RMouseEvent*
                    ap0 =
                    qscriptvalue_cast<
                    RMouseEvent*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RMouseEvent*.",
                               context);                    
                    }
                    RMouseEvent& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->mouseDoubleClickEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.mouseDoubleClickEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::mouseDoubleClickEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::coordinateEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::coordinateEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::coordinateEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("coordinateEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RCoordinateEvent */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    RCoordinateEvent*
                    ap0 =
                    qscriptvalue_cast<
                    RCoordinateEvent*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RCoordinateEvent*.",
                               context);                    
                    }
                    RCoordinateEvent& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->coordinateEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.coordinateEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::coordinateEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::coordinateEventPreview
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::coordinateEventPreview", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::coordinateEventPreview";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("coordinateEventPreview", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RCoordinateEvent */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    RCoordinateEvent*
                    ap0 =
                    qscriptvalue_cast<
                    RCoordinateEvent*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RCoordinateEvent*.",
                               context);                    
                    }
                    RCoordinateEvent& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->coordinateEventPreview(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.coordinateEventPreview().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::coordinateEventPreview", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::commandEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::commandEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::commandEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("commandEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RCommandEvent */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    RCommandEvent*
                    ap0 =
                    qscriptvalue_cast<
                    RCommandEvent*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RCommandEvent*.",
                               context);                    
                    }
                    RCommandEvent& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->commandEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.commandEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::commandEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::commandEventPreview
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::commandEventPreview", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::commandEventPreview";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("commandEventPreview", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RCommandEvent */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    RCommandEvent*
                    ap0 =
                    qscriptvalue_cast<
                    RCommandEvent*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RCommandEvent*.",
                               context);                    
                    }
                    RCommandEvent& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->commandEventPreview(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.commandEventPreview().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::commandEventPreview", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::wheelEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::wheelEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::wheelEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("wheelEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RWheelEvent */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    RWheelEvent*
                    ap0 =
                    qscriptvalue_cast<
                    RWheelEvent*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RWheelEvent*.",
                               context);                    
                    }
                    RWheelEvent& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->wheelEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.wheelEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::wheelEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::tabletEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::tabletEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::tabletEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("tabletEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RTabletEvent */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    RTabletEvent*
                    ap0 =
                    qscriptvalue_cast<
                    RTabletEvent*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RTabletEvent*.",
                               context);                    
                    }
                    RTabletEvent& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->tabletEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.tabletEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::tabletEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::swipeGestureEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::swipeGestureEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::swipeGestureEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("swipeGestureEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: QSwipeGesture */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    QSwipeGesture*
                    ap0 =
                    qscriptvalue_cast<
                    QSwipeGesture*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type QSwipeGesture*.",
                               context);                    
                    }
                    QSwipeGesture& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->swipeGestureEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.swipeGestureEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::swipeGestureEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::panGestureEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::panGestureEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::panGestureEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("panGestureEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: QPanGesture */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    QPanGesture*
                    ap0 =
                    qscriptvalue_cast<
                    QPanGesture*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type QPanGesture*.",
                               context);                    
                    }
                    QPanGesture& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->panGestureEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.panGestureEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::panGestureEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::pinchGestureEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::pinchGestureEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::pinchGestureEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("pinchGestureEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: QPinchGesture */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    QPinchGesture*
                    ap0 =
                    qscriptvalue_cast<
                    QPinchGesture*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type QPinchGesture*.",
                               context);                    
                    }
                    QPinchGesture& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->pinchGestureEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.pinchGestureEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::pinchGestureEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::propertyChangeEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::propertyChangeEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::propertyChangeEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("propertyChangeEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RPropertyEvent */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RPropertyEvent*
                    ap0 =
                    qscriptvalue_cast<
                    RPropertyEvent*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RPropertyEvent.",
                               context);                    
                    }
                    RPropertyEvent 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->propertyChangeEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.propertyChangeEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::propertyChangeEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::ucsSetEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::ucsSetEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::ucsSetEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("ucsSetEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isString()
        ) /* type: QString */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    QString
                    a0 =
                    (QString)
                    
                    context->argument( 0 ).
                    toString();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->ucsSetEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.ucsSetEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::ucsSetEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::zoomChangeEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::zoomChangeEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::zoomChangeEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("zoomChangeEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RGraphicsView */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    RGraphicsView*
                    ap0 =
                    qscriptvalue_cast<
                    RGraphicsView*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RGraphicsView*.",
                               context);                    
                    }
                    RGraphicsView& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->zoomChangeEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.zoomChangeEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::zoomChangeEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::enableUpdates
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::enableUpdates", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::enableUpdates";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("enableUpdates", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->enableUpdates();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.enableUpdates().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::enableUpdates", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::disableUpdates
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::disableUpdates", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::disableUpdates";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("disableUpdates", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->disableUpdates();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.disableUpdates().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::disableUpdates", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::enableRegeneration
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::enableRegeneration", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::enableRegeneration";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("enableRegeneration", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->enableRegeneration();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.enableRegeneration().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::enableRegeneration", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::disableRegeneration
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::disableRegeneration", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::disableRegeneration";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("disableRegeneration", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->disableRegeneration();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.disableRegeneration().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::disableRegeneration", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::enableMouseTracking
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::enableMouseTracking", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::enableMouseTracking";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("enableMouseTracking", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->enableMouseTracking();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.enableMouseTracking().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::enableMouseTracking", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::disableMouseTracking
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::disableMouseTracking", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::disableMouseTracking";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("disableMouseTracking", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->disableMouseTracking();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.disableMouseTracking().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::disableMouseTracking", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::updateAllEntities
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::updateAllEntities", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::updateAllEntities";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("updateAllEntities", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->updateAllEntities();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.updateAllEntities().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::updateAllEntities", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::regenerateScenes
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::regenerateScenes", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::regenerateScenes";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("regenerateScenes", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->regenerateScenes();
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->regenerateScenes(a0);
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isArray()
        ) /* type: QSet < REntity::Id > */
     && (
            context->argument(1).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isArray
                    QSet < REntity::Id >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
                    // argument isStandardType
                    bool
                    a1 =
                    (bool)
                    
                    context->argument( 1 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->regenerateScenes(a0
        ,
    a1);
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isNumber()
        ) /* type: REntity::Id */
     && (
            context->argument(1).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    REntity::Id
                    a0 =
                    (REntity::Id)
                    (int)
                    context->argument( 0 ).
                    toNumber();
                
                    // argument isStandardType
                    bool
                    a1 =
                    (bool)
                    
                    context->argument( 1 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->regenerateScenes(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.regenerateScenes().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::regenerateScenes", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::updateSelectionStatus
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::updateSelectionStatus", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::updateSelectionStatus";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("updateSelectionStatus", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isArray()
        ) /* type: QSet < REntity::Id > */
     && (
            context->argument(1).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isArray
                    QSet < REntity::Id >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
                    // argument isStandardType
                    bool
                    a1 =
                    (bool)
                    
                    context->argument( 1 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->updateSelectionStatus(a0
        ,
    a1);
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isNumber()
        ) /* type: REntity::Id */
     && (
            context->argument(1).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    REntity::Id
                    a0 =
                    (REntity::Id)
                    (int)
                    context->argument( 0 ).
                    toNumber();
                
                    // argument isStandardType
                    bool
                    a1 =
                    (bool)
                    
                    context->argument( 1 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->updateSelectionStatus(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.updateSelectionStatus().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::updateSelectionStatus", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::regenerateViews
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::regenerateViews", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::regenerateViews";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("regenerateViews", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->regenerateViews();
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->regenerateViews(a0);
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isArray()
        ) /* type: QSet < REntity::Id > */
    
    ){
    // prepare arguments:
    
                    // argument isArray
                    QSet < REntity::Id >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->regenerateViews(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.regenerateViews().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::regenerateViews", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::repaintViews
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::repaintViews", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::repaintViews";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("repaintViews", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->repaintViews();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.repaintViews().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::repaintViews", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::registerScene
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::registerScene", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::registerScene";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("registerScene", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RGraphicsScene */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    RGraphicsScene*
                    ap0 =
                    qscriptvalue_cast<
                    RGraphicsScene*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RGraphicsScene*.",
                               context);                    
                    }
                    RGraphicsScene& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->registerScene(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.registerScene().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::registerScene", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::unregisterScene
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::unregisterScene", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::unregisterScene";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("unregisterScene", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RGraphicsScene */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    RGraphicsScene*
                    ap0 =
                    qscriptvalue_cast<
                    RGraphicsScene*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RGraphicsScene*.",
                               context);                    
                    }
                    RGraphicsScene& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->unregisterScene(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.unregisterScene().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::unregisterScene", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::setCursor
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::setCursor", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::setCursor";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("setCursor", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: QCursor */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    QCursor*
                    ap0 =
                    qscriptvalue_cast<
                    QCursor*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type QCursor*.",
                               context);                    
                    }
                    QCursor& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setCursor(a0);
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: QCursor */
     && (
            context->argument(1).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    QCursor*
                    ap0 =
                    qscriptvalue_cast<
                    QCursor*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type QCursor*.",
                               context);                    
                    }
                    QCursor& a0 = *ap0;
                
                    // argument isStandardType
                    bool
                    a1 =
                    (bool)
                    
                    context->argument( 1 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setCursor(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.setCursor().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::setCursor", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::importUrl
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::importUrl", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::importUrl";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("importUrl", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: QUrl */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    QUrl*
                    ap0 =
                    qscriptvalue_cast<
                    QUrl*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type QUrl*.",
                               context);                    
                    }
                    QUrl& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'RDocumentInterface::IoErrorCode'
    RDocumentInterface::IoErrorCode cppResult =
        
               self->importUrl(a0);
        // return type: RDocumentInterface::IoErrorCode
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: QUrl */
     && (
            context->argument(1).isString()
        ) /* type: QString */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    QUrl*
                    ap0 =
                    qscriptvalue_cast<
                    QUrl*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type QUrl*.",
                               context);                    
                    }
                    QUrl& a0 = *ap0;
                
                    // argument isStandardType
                    QString
                    a1 =
                    (QString)
                    
                    context->argument( 1 ).
                    toString();
                
    // end of arguments

    // call C++ function:
    // return type 'RDocumentInterface::IoErrorCode'
    RDocumentInterface::IoErrorCode cppResult =
        
               self->importUrl(a0
        ,
    a1);
        // return type: RDocumentInterface::IoErrorCode
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    3 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: QUrl */
     && (
            context->argument(1).isString()
        ) /* type: QString */
     && (
            context->argument(2).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    QUrl*
                    ap0 =
                    qscriptvalue_cast<
                    QUrl*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type QUrl*.",
                               context);                    
                    }
                    QUrl& a0 = *ap0;
                
                    // argument isStandardType
                    QString
                    a1 =
                    (QString)
                    
                    context->argument( 1 ).
                    toString();
                
                    // argument isStandardType
                    bool
                    a2 =
                    (bool)
                    
                    context->argument( 2 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'RDocumentInterface::IoErrorCode'
    RDocumentInterface::IoErrorCode cppResult =
        
               self->importUrl(a0
        ,
    a1
        ,
    a2);
        // return type: RDocumentInterface::IoErrorCode
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.importUrl().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::importUrl", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::importFile
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::importFile", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::importFile";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("importFile", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isString()
        ) /* type: QString */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    QString
                    a0 =
                    (QString)
                    
                    context->argument( 0 ).
                    toString();
                
    // end of arguments

    // call C++ function:
    // return type 'RDocumentInterface::IoErrorCode'
    RDocumentInterface::IoErrorCode cppResult =
        
               self->importFile(a0);
        // return type: RDocumentInterface::IoErrorCode
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isString()
        ) /* type: QString */
     && (
            context->argument(1).isString()
        ) /* type: QString */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    QString
                    a0 =
                    (QString)
                    
                    context->argument( 0 ).
                    toString();
                
                    // argument isStandardType
                    QString
                    a1 =
                    (QString)
                    
                    context->argument( 1 ).
                    toString();
                
    // end of arguments

    // call C++ function:
    // return type 'RDocumentInterface::IoErrorCode'
    RDocumentInterface::IoErrorCode cppResult =
        
               self->importFile(a0
        ,
    a1);
        // return type: RDocumentInterface::IoErrorCode
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    3 && (
            context->argument(0).isString()
        ) /* type: QString */
     && (
            context->argument(1).isString()
        ) /* type: QString */
     && (
            context->argument(2).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    QString
                    a0 =
                    (QString)
                    
                    context->argument( 0 ).
                    toString();
                
                    // argument isStandardType
                    QString
                    a1 =
                    (QString)
                    
                    context->argument( 1 ).
                    toString();
                
                    // argument isStandardType
                    bool
                    a2 =
                    (bool)
                    
                    context->argument( 2 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'RDocumentInterface::IoErrorCode'
    RDocumentInterface::IoErrorCode cppResult =
        
               self->importFile(a0
        ,
    a1
        ,
    a2);
        // return type: RDocumentInterface::IoErrorCode
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.importFile().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::importFile", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::getCorrectedFileName
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::getCorrectedFileName", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::getCorrectedFileName";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("getCorrectedFileName", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isString()
        ) /* type: QString */
     && (
            context->argument(1).isString()
        ) /* type: QString */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    QString
                    a0 =
                    (QString)
                    
                    context->argument( 0 ).
                    toString();
                
                    // argument isStandardType
                    QString
                    a1 =
                    (QString)
                    
                    context->argument( 1 ).
                    toString();
                
    // end of arguments

    // call C++ function:
    // return type 'QString'
    QString cppResult =
        
               self->getCorrectedFileName(a0
        ,
    a1);
        // return type: QString
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.getCorrectedFileName().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::getCorrectedFileName", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::exportFile
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::exportFile", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::exportFile";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("exportFile", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isString()
        ) /* type: QString */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    QString
                    a0 =
                    (QString)
                    
                    context->argument( 0 ).
                    toString();
                
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->exportFile(a0);
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isString()
        ) /* type: QString */
     && (
            context->argument(1).isString()
        ) /* type: QString */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    QString
                    a0 =
                    (QString)
                    
                    context->argument( 0 ).
                    toString();
                
                    // argument isStandardType
                    QString
                    a1 =
                    (QString)
                    
                    context->argument( 1 ).
                    toString();
                
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->exportFile(a0
        ,
    a1);
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    3 && (
            context->argument(0).isString()
        ) /* type: QString */
     && (
            context->argument(1).isString()
        ) /* type: QString */
     && (
            context->argument(2).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    QString
                    a0 =
                    (QString)
                    
                    context->argument( 0 ).
                    toString();
                
                    // argument isStandardType
                    QString
                    a1 =
                    (QString)
                    
                    context->argument( 1 ).
                    toString();
                
                    // argument isStandardType
                    bool
                    a2 =
                    (bool)
                    
                    context->argument( 2 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->exportFile(a0
        ,
    a1
        ,
    a2);
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.exportFile().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::exportFile", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::tagState
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::tagState", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::tagState";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("tagState", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->tagState();
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isString()
        ) /* type: QString */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    QString
                    a0 =
                    (QString)
                    
                    context->argument( 0 ).
                    toString();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->tagState(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.tagState().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::tagState", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::undoToTag
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::undoToTag", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::undoToTag";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("undoToTag", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->undoToTag();
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isString()
        ) /* type: QString */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    QString
                    a0 =
                    (QString)
                    
                    context->argument( 0 ).
                    toString();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->undoToTag(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.undoToTag().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::undoToTag", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::undo
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::undo", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::undo";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("undo", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->undo();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.undo().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::undo", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::redo
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::redo", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::redo";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("redo", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->redo();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.redo().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::redo", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::flushTransactions
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::flushTransactions", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::flushTransactions";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("flushTransactions", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->flushTransactions();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.flushTransactions().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::flushTransactions", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::flushRedo
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::flushRedo", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::flushRedo";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("flushRedo", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->flushRedo();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.flushRedo().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::flushRedo", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::setSnap
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::setSnap", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::setSnap";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("setSnap", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RSnap * */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RSnap * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RSnap >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RSnap *RSnap *.", context);                    
                    }
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setSnap(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.setSnap().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::setSnap", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::getSnap
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::getSnap", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::getSnap";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("getSnap", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RSnap *'
    RSnap * cppResult =
        
               self->getSnap();
        // return type: RSnap *
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.getSnap().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::getSnap", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::setSnapRestriction
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::setSnapRestriction", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::setSnapRestriction";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("setSnapRestriction", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RSnapRestriction * */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RSnapRestriction * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RSnapRestriction >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RSnapRestriction *RSnapRestriction *.", context);                    
                    }
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setSnapRestriction(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.setSnapRestriction().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::setSnapRestriction", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::getSnapRestriction
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::getSnapRestriction", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::getSnapRestriction";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("getSnapRestriction", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RSnapRestriction *'
    RSnapRestriction * cppResult =
        
               self->getSnapRestriction();
        // return type: RSnapRestriction *
                // RSnapRestriction:
                result = REcmaHelper::toScriptValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.getSnapRestriction().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::getSnapRestriction", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::snap
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::snap", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::snap";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("snap", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RMouseEvent */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    RMouseEvent*
                    ap0 =
                    qscriptvalue_cast<
                    RMouseEvent*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RMouseEvent*.",
                               context);                    
                    }
                    RMouseEvent& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->snap(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RMouseEvent */
     && (
            context->argument(1).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    RMouseEvent*
                    ap0 =
                    qscriptvalue_cast<
                    RMouseEvent*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RMouseEvent*.",
                               context);                    
                    }
                    RMouseEvent& a0 = *ap0;
                
                    // argument isStandardType
                    bool
                    a1 =
                    (bool)
                    
                    context->argument( 1 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->snap(a0
        ,
    a1);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.snap().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::snap", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::restrictOrtho
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::restrictOrtho", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::restrictOrtho";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("restrictOrtho", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap1 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RDocumentInterface: Argument 1 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a1 = 
                    *ap1;
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->restrictOrtho(a0
        ,
    a1);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    3 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RVector */
     && (
            context->argument(2).isVariant() || 
            context->argument(2).isQObject() || 
            context->argument(2).isNull()
        ) /* type: RS::OrthoMode */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap1 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RDocumentInterface: Argument 1 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a1 = 
                    *ap1;
                
                    // argument is reference
                    RS::OrthoMode*
                    ap2 =
                    qscriptvalue_cast<
                    RS::OrthoMode*
                        >(
                        context->argument(
                        2
                        )
                    );
                    if( ap2 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 2 is not of type RS::OrthoMode*.",
                               context);                    
                    }
                    RS::OrthoMode& a2 = *ap2;
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->restrictOrtho(a0
        ,
    a1
        ,
    a2);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.restrictOrtho().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::restrictOrtho", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::getClosestEntity
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::getClosestEntity", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::getClosestEntity";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("getClosestEntity", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RInputEvent */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    RInputEvent*
                    ap0 =
                    qscriptvalue_cast<
                    RInputEvent*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RInputEvent*.",
                               context);                    
                    }
                    RInputEvent& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'REntity::Id'
    REntity::Id cppResult =
        
               self->getClosestEntity(a0);
        // return type: REntity::Id
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isStandardType
                    double
                    a1 =
                    (double)
                    
                    context->argument( 1 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'REntity::Id'
    REntity::Id cppResult =
        
               self->getClosestEntity(a0
        ,
    a1);
        // return type: REntity::Id
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    3 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isNumber()
        ) /* type: double */
     && (
            context->argument(2).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isStandardType
                    double
                    a1 =
                    (double)
                    
                    context->argument( 1 ).
                    toNumber();
                
                    // argument isStandardType
                    double
                    a2 =
                    (double)
                    
                    context->argument( 2 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'REntity::Id'
    REntity::Id cppResult =
        
               self->getClosestEntity(a0
        ,
    a1
        ,
    a2);
        // return type: REntity::Id
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    4 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isNumber()
        ) /* type: double */
     && (
            context->argument(2).isNumber()
        ) /* type: double */
     && (
            context->argument(3).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isStandardType
                    double
                    a1 =
                    (double)
                    
                    context->argument( 1 ).
                    toNumber();
                
                    // argument isStandardType
                    double
                    a2 =
                    (double)
                    
                    context->argument( 2 ).
                    toNumber();
                
                    // argument isStandardType
                    bool
                    a3 =
                    (bool)
                    
                    context->argument( 3 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'REntity::Id'
    REntity::Id cppResult =
        
               self->getClosestEntity(a0
        ,
    a1
        ,
    a2
        ,
    a3);
        // return type: REntity::Id
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    5 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isNumber()
        ) /* type: double */
     && (
            context->argument(2).isNumber()
        ) /* type: double */
     && (
            context->argument(3).isBool()
        ) /* type: bool */
     && (
            context->argument(4).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isStandardType
                    double
                    a1 =
                    (double)
                    
                    context->argument( 1 ).
                    toNumber();
                
                    // argument isStandardType
                    double
                    a2 =
                    (double)
                    
                    context->argument( 2 ).
                    toNumber();
                
                    // argument isStandardType
                    bool
                    a3 =
                    (bool)
                    
                    context->argument( 3 ).
                    toBool();
                
                    // argument isStandardType
                    bool
                    a4 =
                    (bool)
                    
                    context->argument( 4 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'REntity::Id'
    REntity::Id cppResult =
        
               self->getClosestEntity(a0
        ,
    a1
        ,
    a2
        ,
    a3
        ,
    a4);
        // return type: REntity::Id
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.getClosestEntity().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::getClosestEntity", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::highlightEntity
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::highlightEntity", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::highlightEntity";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("highlightEntity", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: REntity::Id */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    REntity::Id
                    a0 =
                    (REntity::Id)
                    (int)
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->highlightEntity(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.highlightEntity().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::highlightEntity", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::highlightReferencePoint
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::highlightReferencePoint", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::highlightReferencePoint";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("highlightReferencePoint", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RRefPoint */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RRefPoint*
                    ap0 =
                    qscriptvalue_cast<
                    RRefPoint*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RRefPoint.",
                               context);                    
                    }
                    RRefPoint 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->highlightReferencePoint(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.highlightReferencePoint().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::highlightReferencePoint", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::selectEntities
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::selectEntities", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::selectEntities";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("selectEntities", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isArray()
        ) /* type: QSet < REntity::Id > */
    
    ){
    // prepare arguments:
    
                    // argument isArray
                    QSet < REntity::Id >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
    // end of arguments

    // call C++ function:
    // return type 'int'
    int cppResult =
        
               self->selectEntities(a0);
        // return type: int
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isArray()
        ) /* type: QSet < REntity::Id > */
     && (
            context->argument(1).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isArray
                    QSet < REntity::Id >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
                    // argument isStandardType
                    bool
                    a1 =
                    (bool)
                    
                    context->argument( 1 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'int'
    int cppResult =
        
               self->selectEntities(a0
        ,
    a1);
        // return type: int
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.selectEntities().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::selectEntities", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::selectEntity
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::selectEntity", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::selectEntity";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("selectEntity", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: REntity::Id */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    REntity::Id
                    a0 =
                    (REntity::Id)
                    (int)
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->selectEntity(a0);
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isNumber()
        ) /* type: REntity::Id */
     && (
            context->argument(1).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    REntity::Id
                    a0 =
                    (REntity::Id)
                    (int)
                    context->argument( 0 ).
                    toNumber();
                
                    // argument isStandardType
                    bool
                    a1 =
                    (bool)
                    
                    context->argument( 1 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->selectEntity(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.selectEntity().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::selectEntity", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::deselectEntities
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::deselectEntities", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::deselectEntities";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("deselectEntities", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isArray()
        ) /* type: QSet < REntity::Id > */
    
    ){
    // prepare arguments:
    
                    // argument isArray
                    QSet < REntity::Id >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
    // end of arguments

    // call C++ function:
    // return type 'int'
    int cppResult =
        
               self->deselectEntities(a0);
        // return type: int
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.deselectEntities().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::deselectEntities", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::deselectEntity
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::deselectEntity", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::deselectEntity";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("deselectEntity", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: REntity::Id */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    REntity::Id
                    a0 =
                    (REntity::Id)
                    (int)
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->deselectEntity(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.deselectEntity().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::deselectEntity", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::selectBoxXY
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::selectBoxXY", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::selectBoxXY";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("selectBoxXY", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RBox */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RBox*
                    ap0 =
                    qscriptvalue_cast<
                    RBox*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RBox.",
                               context);                    
                    }
                    RBox 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->selectBoxXY(a0);
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RBox */
     && (
            context->argument(1).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RBox*
                    ap0 =
                    qscriptvalue_cast<
                    RBox*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RBox.",
                               context);                    
                    }
                    RBox 
                    a0 = 
                    *ap0;
                
                    // argument isStandardType
                    bool
                    a1 =
                    (bool)
                    
                    context->argument( 1 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->selectBoxXY(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.selectBoxXY().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::selectBoxXY", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::selectAll
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::selectAll", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::selectAll";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("selectAll", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->selectAll();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.selectAll().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::selectAll", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::deselectAll
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::deselectAll", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::deselectAll";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("deselectAll", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->deselectAll();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.deselectAll().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::deselectAll", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::clearSelection
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::clearSelection", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::clearSelection";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("clearSelection", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->clearSelection();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.clearSelection().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::clearSelection", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::hasSelection
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::hasSelection", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::hasSelection";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("hasSelection", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->hasSelection();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.hasSelection().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::hasSelection", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::addZoomBoxToPreview
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::addZoomBoxToPreview", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::addZoomBoxToPreview";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("addZoomBoxToPreview", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RBox */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RBox*
                    ap0 =
                    qscriptvalue_cast<
                    RBox*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RBox.",
                               context);                    
                    }
                    RBox 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->addZoomBoxToPreview(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.addZoomBoxToPreview().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::addZoomBoxToPreview", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::addShapeToPreview
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::addShapeToPreview", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::addShapeToPreview";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("addShapeToPreview", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    5 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RShape */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RColor */
     && (
            context->argument(2).isVariant() || 
            context->argument(2).isQObject() || 
            context->argument(2).isNull()
        ) /* type: QBrush */
     && (
            context->argument(3).isNumber()
        ) /* type: RLineweight::Lineweight */
     && (
            context->argument(4).isNumber()
        ) /* type: Qt::PenStyle */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    RShape*
                    ap0 =
                    qscriptvalue_cast<
                    RShape*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RShape*.",
                               context);                    
                    }
                    RShape& a0 = *ap0;
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RColor*
                    ap1 =
                    qscriptvalue_cast<
                    RColor*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RDocumentInterface: Argument 1 is not of type RColor.",
                               context);                    
                    }
                    RColor 
                    a1 = 
                    *ap1;
                
                    // argument is reference
                    QBrush*
                    ap2 =
                    qscriptvalue_cast<
                    QBrush*
                        >(
                        context->argument(
                        2
                        )
                    );
                    if( ap2 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 2 is not of type QBrush*.",
                               context);                    
                    }
                    QBrush& a2 = *ap2;
                
                    // argument isStandardType
                    RLineweight::Lineweight
                    a3 =
                    (RLineweight::Lineweight)
                    (int)
                    context->argument( 3 ).
                    toNumber();
                
                    // argument isStandardType
                    Qt::PenStyle
                    a4 =
                    (Qt::PenStyle)
                    (int)
                    context->argument( 4 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->addShapeToPreview(a0
        ,
    a1
        ,
    a2
        ,
    a3
        ,
    a4);
    } else


        
    
    if( context->argumentCount() ==
    6 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RShape */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RColor */
     && (
            context->argument(2).isVariant() || 
            context->argument(2).isQObject() || 
            context->argument(2).isNull()
        ) /* type: QBrush */
     && (
            context->argument(3).isNumber()
        ) /* type: RLineweight::Lineweight */
     && (
            context->argument(4).isNumber()
        ) /* type: Qt::PenStyle */
     && (
            context->argument(5).isArray()
        ) /* type: QList < qreal > */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    RShape*
                    ap0 =
                    qscriptvalue_cast<
                    RShape*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RShape*.",
                               context);                    
                    }
                    RShape& a0 = *ap0;
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RColor*
                    ap1 =
                    qscriptvalue_cast<
                    RColor*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RDocumentInterface: Argument 1 is not of type RColor.",
                               context);                    
                    }
                    RColor 
                    a1 = 
                    *ap1;
                
                    // argument is reference
                    QBrush*
                    ap2 =
                    qscriptvalue_cast<
                    QBrush*
                        >(
                        context->argument(
                        2
                        )
                    );
                    if( ap2 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 2 is not of type QBrush*.",
                               context);                    
                    }
                    QBrush& a2 = *ap2;
                
                    // argument isStandardType
                    RLineweight::Lineweight
                    a3 =
                    (RLineweight::Lineweight)
                    (int)
                    context->argument( 3 ).
                    toNumber();
                
                    // argument isStandardType
                    Qt::PenStyle
                    a4 =
                    (Qt::PenStyle)
                    (int)
                    context->argument( 4 ).
                    toNumber();
                
                    // argument isArray
                    QList < qreal >
                    a5;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(5),
                        a5
                    );
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->addShapeToPreview(a0
        ,
    a1
        ,
    a2
        ,
    a3
        ,
    a4
        ,
    a5);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.addShapeToPreview().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::addShapeToPreview", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::addAuxShapeToPreview
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::addAuxShapeToPreview", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::addAuxShapeToPreview";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("addAuxShapeToPreview", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RShape */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    RShape*
                    ap0 =
                    qscriptvalue_cast<
                    RShape*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RShape*.",
                               context);                    
                    }
                    RShape& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->addAuxShapeToPreview(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.addAuxShapeToPreview().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::addAuxShapeToPreview", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::addEntityToPreview
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::addEntityToPreview", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::addEntityToPreview";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("addEntityToPreview", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: REntity */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    REntity*
                    ap0 =
                    qscriptvalue_cast<
                    REntity*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type REntity*.",
                               context);                    
                    }
                    REntity& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->addEntityToPreview(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.addEntityToPreview().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::addEntityToPreview", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::addDrawableToPreview
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::addDrawableToPreview", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::addDrawableToPreview";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("addDrawableToPreview", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RGraphicsSceneDrawable */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RGraphicsSceneDrawable*
                    ap0 =
                    qscriptvalue_cast<
                    RGraphicsSceneDrawable*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RGraphicsSceneDrawable.",
                               context);                    
                    }
                    RGraphicsSceneDrawable 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->addDrawableToPreview(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.addDrawableToPreview().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::addDrawableToPreview", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::beginPreview
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::beginPreview", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::beginPreview";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("beginPreview", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->beginPreview();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.beginPreview().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::beginPreview", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::endPreview
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::endPreview", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::endPreview";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("endPreview", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->endPreview();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.endPreview().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::endPreview", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::clearPreview
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::clearPreview", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::clearPreview";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("clearPreview", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->clearPreview();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.clearPreview().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::clearPreview", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::isPreviewEmpty
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::isPreviewEmpty", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::isPreviewEmpty";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("isPreviewEmpty", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->isPreviewEmpty();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.isPreviewEmpty().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::isPreviewEmpty", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::keepPreview
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::keepPreview", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::keepPreview";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("keepPreview", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->keepPreview();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.keepPreview().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::keepPreview", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::showPropertiesOf
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::showPropertiesOf", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::showPropertiesOf";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("showPropertiesOf", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: REntity */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    REntity*
                    ap0 =
                    qscriptvalue_cast<
                    REntity*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type REntity*.",
                               context);                    
                    }
                    REntity& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->showPropertiesOf(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.showPropertiesOf().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::showPropertiesOf", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::clearProperties
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::clearProperties", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::clearProperties";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("clearProperties", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->clearProperties();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.clearProperties().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::clearProperties", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::zoomIn
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::zoomIn", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::zoomIn";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("zoomIn", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->zoomIn();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.zoomIn().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::zoomIn", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::zoomOut
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::zoomOut", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::zoomOut";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("zoomOut", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->zoomOut();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.zoomOut().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::zoomOut", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::autoZoom
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::autoZoom", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::autoZoom";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("autoZoom", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->autoZoom();
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: int */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    int
                    a0 =
                    (int)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->autoZoom(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.autoZoom().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::autoZoom", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::zoomToSelection
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::zoomToSelection", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::zoomToSelection";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("zoomToSelection", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->zoomToSelection();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.zoomToSelection().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::zoomToSelection", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::zoomTo
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::zoomTo", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::zoomTo";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("zoomTo", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RBox */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RBox*
                    ap0 =
                    qscriptvalue_cast<
                    RBox*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RBox.",
                               context);                    
                    }
                    RBox 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->zoomTo(a0);
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RBox */
     && (
            context->argument(1).isNumber()
        ) /* type: int */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RBox*
                    ap0 =
                    qscriptvalue_cast<
                    RBox*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RBox.",
                               context);                    
                    }
                    RBox 
                    a0 = 
                    *ap0;
                
                    // argument isStandardType
                    int
                    a1 =
                    (int)
                    
                    context->argument( 1 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->zoomTo(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.zoomTo().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::zoomTo", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::zoomPrevious
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::zoomPrevious", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::zoomPrevious";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("zoomPrevious", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->zoomPrevious();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.zoomPrevious().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::zoomPrevious", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::previewOperation
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::previewOperation", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::previewOperation";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("previewOperation", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: ROperation * */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    ROperation * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<ROperation >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type ROperation *ROperation *.", context);                    
                    }
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->previewOperation(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.previewOperation().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::previewOperation", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::applyOperation
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::applyOperation", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::applyOperation";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("applyOperation", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: ROperation * */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    ROperation * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<ROperation >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type ROperation *ROperation *.", context);                    
                    }
                
    // end of arguments

    // call C++ function:
    // return type 'RTransaction'
    RTransaction cppResult =
        
               self->applyOperation(a0);
        // return type: RTransaction
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.applyOperation().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::applyOperation", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::objectChangeEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::objectChangeEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::objectChangeEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("objectChangeEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RTransaction */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RTransaction*
                    ap0 =
                    qscriptvalue_cast<
                    RTransaction*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RTransaction.",
                               context);                    
                    }
                    RTransaction 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->objectChangeEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.objectChangeEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::objectChangeEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::getRelativeZero
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::getRelativeZero", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::getRelativeZero";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("getRelativeZero", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->getRelativeZero();
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.getRelativeZero().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::getRelativeZero", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::getLastPosition
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::getLastPosition", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::getLastPosition";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("getLastPosition", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->getLastPosition();
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.getLastPosition().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::getLastPosition", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::setRelativeZero
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::setRelativeZero", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::setRelativeZero";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("setRelativeZero", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setRelativeZero(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.setRelativeZero().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::setRelativeZero", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::lockRelativeZero
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::lockRelativeZero", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::lockRelativeZero";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("lockRelativeZero", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->lockRelativeZero();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.lockRelativeZero().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::lockRelativeZero", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::unlockRelativeZero
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::unlockRelativeZero", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::unlockRelativeZero";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("unlockRelativeZero", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->unlockRelativeZero();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.unlockRelativeZero().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::unlockRelativeZero", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::isRelativeZeroLocked
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::isRelativeZeroLocked", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::isRelativeZeroLocked";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("isRelativeZeroLocked", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->isRelativeZeroLocked();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.isRelativeZeroLocked().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::isRelativeZeroLocked", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::lockSnap
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::lockSnap", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::lockSnap";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("lockSnap", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->lockSnap();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.lockSnap().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::lockSnap", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::unlockSnap
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::unlockSnap", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::unlockSnap";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("unlockSnap", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->unlockSnap();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.unlockSnap().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::unlockSnap", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::toggleSnapLock
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::toggleSnapLock", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::toggleSnapLock";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("toggleSnapLock", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->toggleSnapLock();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.toggleSnapLock().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::toggleSnapLock", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::isSnapLocked
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::isSnapLocked", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::isSnapLocked";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("isSnapLocked", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->isSnapLocked();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.isSnapLocked().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::isSnapLocked", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::getCursorPosition
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::getCursorPosition", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::getCursorPosition";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("getCursorPosition", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->getCursorPosition();
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.getCursorPosition().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::getCursorPosition", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::setCursorPosition
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::setCursorPosition", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::setCursorPosition";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("setCursorPosition", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setCursorPosition(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.setCursorPosition().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::setCursorPosition", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::setCursorOverride
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::setCursorOverride", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::setCursorOverride";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("setCursorOverride", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setCursorOverride(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.setCursorOverride().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::setCursorOverride", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::getCursorOverride
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::getCursorOverride", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::getCursorOverride";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("getCursorOverride", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->getCursorOverride();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.getCursorOverride().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::getCursorOverride", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::deleteTerminatedActions
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::deleteTerminatedActions", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::deleteTerminatedActions";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("deleteTerminatedActions", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->deleteTerminatedActions();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.deleteTerminatedActions().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::deleteTerminatedActions", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::setCurrentColor
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::setCurrentColor", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::setCurrentColor";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("setCurrentColor", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RColor */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RColor*
                    ap0 =
                    qscriptvalue_cast<
                    RColor*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RColor.",
                               context);                    
                    }
                    RColor 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setCurrentColor(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.setCurrentColor().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::setCurrentColor", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::getCurrentColor
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::getCurrentColor", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::getCurrentColor";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("getCurrentColor", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RColor'
    RColor cppResult =
        
               self->getCurrentColor();
        // return type: RColor
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.getCurrentColor().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::getCurrentColor", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::setCurrentLineweight
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::setCurrentLineweight", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::setCurrentLineweight";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("setCurrentLineweight", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: RLineweight::Lineweight */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    RLineweight::Lineweight
                    a0 =
                    (RLineweight::Lineweight)
                    (int)
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setCurrentLineweight(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.setCurrentLineweight().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::setCurrentLineweight", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::getCurrentLineweight
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::getCurrentLineweight", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::getCurrentLineweight";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("getCurrentLineweight", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RLineweight::Lineweight'
    RLineweight::Lineweight cppResult =
        
               self->getCurrentLineweight();
        // return type: RLineweight::Lineweight
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.getCurrentLineweight().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::getCurrentLineweight", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::setCurrentLinetype
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::setCurrentLinetype", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::setCurrentLinetype";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("setCurrentLinetype", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: RLinetype::Id */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    RLinetype::Id
                    a0 =
                    (RLinetype::Id)
                    (int)
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setCurrentLinetype(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.setCurrentLinetype().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::setCurrentLinetype", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::setCurrentLinetypePattern
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::setCurrentLinetypePattern", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::setCurrentLinetypePattern";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("setCurrentLinetypePattern", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RLinetypePattern */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RLinetypePattern*
                    ap0 =
                    qscriptvalue_cast<
                    RLinetypePattern*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RLinetypePattern.",
                               context);                    
                    }
                    RLinetypePattern 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setCurrentLinetypePattern(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.setCurrentLinetypePattern().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::setCurrentLinetypePattern", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::getCurrentLinetypeId
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::getCurrentLinetypeId", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::getCurrentLinetypeId";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("getCurrentLinetypeId", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RLinetype::Id'
    RLinetype::Id cppResult =
        
               self->getCurrentLinetypeId();
        // return type: RLinetype::Id
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.getCurrentLinetypeId().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::getCurrentLinetypeId", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::getCurrentLinetypePattern
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::getCurrentLinetypePattern", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::getCurrentLinetypePattern";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("getCurrentLinetypePattern", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RLinetypePattern'
    RLinetypePattern cppResult =
        
               self->getCurrentLinetypePattern();
        // return type: RLinetypePattern
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.getCurrentLinetypePattern().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::getCurrentLinetypePattern", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::setCurrentLayer
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::setCurrentLayer", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::setCurrentLayer";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("setCurrentLayer", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: RLayer::Id */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    RLayer::Id
                    a0 =
                    (RLayer::Id)
                    (int)
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setCurrentLayer(a0);
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RLayer */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    RLayer*
                    ap0 =
                    qscriptvalue_cast<
                    RLayer*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RLayer*.",
                               context);                    
                    }
                    RLayer& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setCurrentLayer(a0);
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isString()
        ) /* type: QString */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    QString
                    a0 =
                    (QString)
                    
                    context->argument( 0 ).
                    toString();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setCurrentLayer(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.setCurrentLayer().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::setCurrentLayer", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::setCurrentBlock
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::setCurrentBlock", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::setCurrentBlock";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("setCurrentBlock", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: RBlock::Id */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    RBlock::Id
                    a0 =
                    (RBlock::Id)
                    (int)
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setCurrentBlock(a0);
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RBlock */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    RBlock*
                    ap0 =
                    qscriptvalue_cast<
                    RBlock*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RBlock*.",
                               context);                    
                    }
                    RBlock& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setCurrentBlock(a0);
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isString()
        ) /* type: QString */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    QString
                    a0 =
                    (QString)
                    
                    context->argument( 0 ).
                    toString();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setCurrentBlock(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.setCurrentBlock().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::setCurrentBlock", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::setCurrentViewport
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::setCurrentViewport", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::setCurrentViewport";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("setCurrentViewport", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RViewportEntity */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    RViewportEntity*
                    ap0 =
                    qscriptvalue_cast<
                    RViewportEntity*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RViewportEntity*.",
                               context);                    
                    }
                    RViewportEntity& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setCurrentViewport(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.setCurrentViewport().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::setCurrentViewport", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::unsetCurrentViewport
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::unsetCurrentViewport", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::unsetCurrentViewport";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("unsetCurrentViewport", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->unsetCurrentViewport();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.unsetCurrentViewport().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::unsetCurrentViewport", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::setCurrentView
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::setCurrentView", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::setCurrentView";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("setCurrentView", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isString()
        ) /* type: QString */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    QString
                    a0 =
                    (QString)
                    
                    context->argument( 0 ).
                    toString();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setCurrentView(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.setCurrentView().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::setCurrentView", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::setCurrentUcs
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::setCurrentUcs", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::setCurrentUcs";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("setCurrentUcs", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RUcs */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    RUcs*
                    ap0 =
                    qscriptvalue_cast<
                    RUcs*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RUcs*.",
                               context);                    
                    }
                    RUcs& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setCurrentUcs(a0);
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isString()
        ) /* type: QString */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    QString
                    a0 =
                    (QString)
                    
                    context->argument( 0 ).
                    toString();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setCurrentUcs(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.setCurrentUcs().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::setCurrentUcs", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::getCurrentUcs
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::getCurrentUcs", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::getCurrentUcs";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("getCurrentUcs", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RUcs'
    RUcs cppResult =
        
               self->getCurrentUcs();
        // return type: RUcs
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.getCurrentUcs().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::getCurrentUcs", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::getCurrentUcsName
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::getCurrentUcsName", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::getCurrentUcsName";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("getCurrentUcsName", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'QString'
    QString cppResult =
        
               self->getCurrentUcsName();
        // return type: QString
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.getCurrentUcsName().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::getCurrentUcsName", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::getLastKnownViewWithFocus
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::getLastKnownViewWithFocus", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::getLastKnownViewWithFocus";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("getLastKnownViewWithFocus", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RGraphicsView *'
    RGraphicsView * cppResult =
        
               self->getLastKnownViewWithFocus();
        // return type: RGraphicsView *
                // RGraphicsView:
                result = REcmaHelper::toScriptValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.getLastKnownViewWithFocus().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::getLastKnownViewWithFocus", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::setLastKnownViewWithFocus
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::setLastKnownViewWithFocus", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::setLastKnownViewWithFocus";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("setLastKnownViewWithFocus", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RGraphicsView * */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RGraphicsView * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RGraphicsView >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RDocumentInterface: Argument 0 is not of type RGraphicsView *RGraphicsView *.", context);                    
                    }
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setLastKnownViewWithFocus(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.setLastKnownViewWithFocus().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::setLastKnownViewWithFocus", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::getClipboard
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::getClipboard", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::getClipboard";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RDocumentInterface &'
    RDocumentInterface & cppResult =
        RDocumentInterface::
       getClipboard();
        // return type: RDocumentInterface &
                // reference
                result = engine->newVariant(
                QVariant::fromValue(&cppResult));
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.getClipboard().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::getClipboard", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::deleteClipboard
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::deleteClipboard", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::deleteClipboard";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    RDocumentInterface::
       deleteClipboard();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.deleteClipboard().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::deleteClipboard", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::isClipboard
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::isClipboard", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::isClipboard";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("isClipboard", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->isClipboard();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.isClipboard().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::isClipboard", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::isSuspended
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::isSuspended", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::isSuspended";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("isSuspended", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->isSuspended();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.isSuspended().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::isSuspended", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::setNotifyListeners
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::setNotifyListeners", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::setNotifyListeners";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("setNotifyListeners", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setNotifyListeners(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.setNotifyListeners().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::setNotifyListeners", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::getNotifyListeners
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::getNotifyListeners", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::getNotifyListeners";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("getNotifyListeners", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->getNotifyListeners();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.getNotifyListeners().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::getNotifyListeners", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::isDeleting
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::isDeleting", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::isDeleting";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("isDeleting", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->isDeleting();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.isDeleting().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::isDeleting", context, engine);
            return result;
        }
         QScriptValue
        REcmaDocumentInterface::eval
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaDocumentInterface::eval", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaDocumentInterface::eval";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RDocumentInterface* self = 
                        getSelf("eval", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isString()
        ) /* type: QString */
     && (
            context->argument(1).isString()
        ) /* type: QString */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    QString
                    a0 =
                    (QString)
                    
                    context->argument( 0 ).
                    toString();
                
                    // argument isStandardType
                    QString
                    a1 =
                    (QString)
                    
                    context->argument( 1 ).
                    toString();
                
    // end of arguments

    // call C++ function:
    // return type 'QVariant'
    QVariant cppResult =
        
               self->eval(a0
        ,
    a1);
        // return type: QVariant
                // QVariant:
                result = REcmaHelper::toScriptValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RDocumentInterface.eval().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaDocumentInterface::eval", context, engine);
            return result;
        }
         QScriptValue REcmaDocumentInterface::toString
    (QScriptContext *context, QScriptEngine *engine)
    
    {

    RDocumentInterface* self = getSelf("toString", context);
    
    QString result;
    
            result = QString("RDocumentInterface(0x%1)").arg((unsigned long int)self, 0, 16);
        
    return QScriptValue(result);
    }
     QScriptValue REcmaDocumentInterface::destroy(QScriptContext *context, QScriptEngine *engine)
    
    {

        RDocumentInterface* self = getSelf("RDocumentInterface", context);
        //Q_ASSERT(self!=NULL);
        if (self==NULL) {
            return REcmaHelper::throwError("self is NULL", context);
        }
        
    
        delete self;
        context->thisObject().setData(engine->nullValue());
        context->thisObject().prototype().setData(engine->nullValue());
        context->thisObject().setPrototype(engine->nullValue());
        context->thisObject().setScriptClass(NULL);
        return engine->undefinedValue();
    }
    RDocumentInterface* REcmaDocumentInterface::getSelf(const QString& fName, QScriptContext* context)
    
        {
            RDocumentInterface* self = NULL;

            
                // self could be a normal object (e.g. from an UI file) or
                // an ECMA shell object (made from an ECMA script):
                //self = getSelfShell(fName, context);
                

            //if (self==NULL) {
                self = REcmaHelper::scriptValueTo<RDocumentInterface >(context->thisObject())
                
                ;
            //}

            if (self == NULL){
                // avoid recursion (toString is used by the backtrace):
                if (fName!="toString") {
                    REcmaHelper::throwError(QString("RDocumentInterface.%1(): "
                        "This object is not a RDocumentInterface").arg(fName),
                        context);
                }
                return NULL;
            }

            return self;
        }
        RDocumentInterface* REcmaDocumentInterface::getSelfShell(const QString& fName, QScriptContext* context)
    
        {
          RDocumentInterface* selfBase = getSelf(fName, context);
                RDocumentInterface* self = dynamic_cast<RDocumentInterface*>(selfBase);
                //return REcmaHelper::scriptValueTo<RDocumentInterface >(context->thisObject());
            if(self == NULL){
                REcmaHelper::throwError(QString("RDocumentInterface.%1(): "
                    "This object is not a RDocumentInterface").arg(fName),
                    context);
            }

            return self;
            


        }
         QScriptValue REcmaDocumentInterface::toScriptValueEnumIoErrorCode(QScriptEngine* engine, const RDocumentInterface::IoErrorCode& value)
    
        {
            return QScriptValue(engine, (int)value);
        }
         void REcmaDocumentInterface::fromScriptValueEnumIoErrorCode(const QScriptValue& value, RDocumentInterface::IoErrorCode& out)
    
        {
            out = qvariant_cast<RDocumentInterface::IoErrorCode>(value.toVariant());
        }
        